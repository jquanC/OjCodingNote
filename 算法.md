## 分治法

### 1-最大子数组问题

**问题描述**

​		给定一个数组，求其最大连续子数组的和

**策略**

​		分治法解,将原问题转化为：比较左子数组的最大子数组、右子数组的最大子数组、跨中间 位置的最大子数组中的最大者，就是原问题的解。通过这样的转化，原问题可以不断划分为小问题。

​		关键是求和理解跨中间最大子数组。跨中间最大子数组并非原问题的最大子数组。它必须要跨中间元素，求解该子问题只需要 **O(n)**的时间复杂度。

**实现**

```c++
//伪代码
//求跨中间元素的最大子数组
FIND-MAX-CROSSING-SUBARRAY(low,high,mid,A) 
	lest-sum = ∞
	sum=0
	for i=mid down to low
		sum+=A[i]
		if sum>left-sum
			left-sum = sum
			max-left=i
	lest-sum = ∞
	sum=0
	for j=mod up to high
		sum+=A[i]
		if sum>right-sum
			right-sum=sum
			max-right=j
	return(max-left,max-right,left-sum+right-sum)
            
//递归求解问题
	
FIND-MAX-SUBARRAY(low,high,A)
	//递归截止条件
	if(low == high) return(low,high,A[low])
		
	mid= Dint((low+high)/2)
	(left-low,left-high,left-sum)=FIND-MAX-SUBARRAY(low,mid,A)
	(right-low,right-high,right-sum)=FIND-MAX-SUBARRY(mid,right,A)
	(cross-low,cross-right,cross-sum)=FIND-MAX-CROSSIN-SUBARRY(low,high,A)
	
	if(left-sum>=cross-sum&&left-sum>=riht-sum) return(left-low,left-high,left-sum)
	if(right-sum>=cross-sum&&riht-sum>=left-sum) return(right-low,riht-high,right-sum)
	if(cross-sum>=left-sum&&cross-sum>=riht-sum) return(cross-low,cross-high,cross-sum)

```

### 2-两个有序数组的中位数问题

**问题描述**		

​		给定两个大小为 m 和 n 的有序数组 A 和 B 。逻辑上归并后的数组为C。请找出C的中位数。要求算法的时间复杂度为 O(log (m+n)) ；

**分析** 

​		要实现这个时间复杂度，用分治法；用最后一步归并方法也可以求解，但时间复杂度是 **O(m+n)**。

​		**一开始的问题：找中位数就是找(归并后)第k个数，k定义如下：**
​		**(len(A)+len(B))为偶**：令k1=(len(A)+len(B))/2 和k2=(len(A)+len(B))/2 +1 个; (C[k]+C[k+1])/2 就是中位数;中位数不一定就要是原来存在的元素，比如元素个数是偶数的时候通过这样求得。
​		**(len(A)+len(B))为奇：**令k=(len(A)+len(B))/2 + 1，C[k]既是
​	但是,这是两个有序数组，**有更好的解法：**
​	还是定义k=(len(A)+len(B))/2
​		令 p=k/2-1,q=k/2(=k-p-1), p+q=k-1;//我们要找第k个数，通过数组特征分解第k-1个数来分解问题
​		对于A[p]、B[q]的较小者，其所在序列的前面部分，肯定不包含目标值(另个不确定哦-这是理解的关键。另一个数组的前面任意一个数，都有可能是要求的数。考虑一个数组元素完全大于另外一个数组的情况)
​		可以抛弃得到子序列！问题规模缩小了！
​		我们先看A[p] B[q]这两个数的大小,可以获得如下信息
​		if A[p] = B[q] , return A[p] 或者B[q]
​		if A[p] < B[q] , 在A[p+1,len(A)] 和 B[0,len(B)]中搜索第k-p个数
​		if A[p] > B[q] , 在A[0,len(A)] 和 B[q+1,len(B)]中搜索第k-q个数



**实现**

```C
//代码实现
		Find-Middle-Element(A,B)
			k=(len(A)+len(B))/2
			if((len(A)+len(B))%2==0)
				return (Find-NoK(A,B,0,len(A)-1,0,len(B)-1,k)+Find-NoK(A,B,0,len(A)-1,0,len(B)-1,k+1))/2
			else return Find-NoK(A,B,0,len(A)-1,0,len(B)-1,k+1)
		
		Find-Nok(A,B,Astart,Aend,Bstart,Bend,k)
			
			if((Aend-Astart)>(Bend-Bstart))
				return Find-Nok(B,A,Bstart,Bend,Astart,Aend,k)//保证len1始终最短-简化下面讨论代码
			if((Astart-Aend)==0) return B[k]
			
			if(k==1) return min(A[start],B[start]) //边界之一；
			p = min(k/2,Aend-Asatrt) //最短的是A数组了，前面简化作用体现出来了
			q=k-q
			if(A[Astatrt+p-1]<B[Bstatrt+q-1]) return(A,B,Astart+p,Aend,Bsatrt,Bend,k-p)
			if(A[Astatrt+p-1]>B[Bstatrt+q-1]) return(A,B,Astart,Aend,Bsatrt+q,Bend,k-q)	
			if(()==()) return A[Astatr+p-1] //想等，这两个一个是k-1,一个是 k，就是我们要找的，直接返回
```



## 堆和堆排序

**基本堆操作**

堆相关的3个操作；注意建堆的渐进紧确界是 **O(n)**

```c
//以A[i]为根，1次自上而下堆化过程
	MAX-HEAPIFY(A,i,n)
		l=LEFT(i)
		r=RIGHT(i)
		if(l>n) return ;
		if(r>n) return ;
		if(A[l]<=A[r]&&A[r]>A[i]) 
			swap(A[i],A[r])
			MAX-HEAPIFY(A,r,n)
		if(A[r]<=A[l]&&A[l]>A[i]) 
			swap(A[i],A[l])
			MAX-HEAPIFY(A,l,n)
			
	//课本版本
	MAX-HEAPIFY(A,i,n)
		l=LEFT(i)
		r=RIGHT(i)
		if(l<=n&&A[l]>A[i])
			largest = l
		else larest = i
		if(r<=n&&A[r]>A[largest])
			largest = r
		if largest!=i
			swap(A[i],A[largest])
			MAX-HEAPIFY(A,largest,n)
	//建堆
	BUILD-MAX-HEAP(A,n)
		for i= Dint(n/2) down to 1
			MAX-HEAPIFY(A,i,n)
	
	//堆排序	
	HEAPSORT(A,n) //递归版本
	if n>=1
		BUILD-MAX-HEAP(A,n)
		swap(A[0],A[n])
		HEAPIFY-SORT(A,n-1)
		
	HEAPSORT(A,n) //非递归版本
		BUILD-MAX-HEAP(A,n)
		for i=n downto 1
		swap(A[0],A[i])
		MAX-HEAPIFY(A,0,i-1)
```



### 基于堆排序的最大优先队列

**基于数据结构的操作描述**

​		用最大堆实现一个最大优先队列
​		最大优先队列，队列每个元素有一个权重key;

​		INSERT(S,x):把元素x插入集合S中
​		MAXIMUM(S):返回S中具有最大关键字的元素
​		EXTRACT-MAX(S)：去掉并返回S中具有最大关键字的元素
​		INCERASE-KEY(S,x,k):将元素x的关键字增加到k;k需要比原来key大

​		显然，最大最小堆是根据key大小来建立的

**实现**

```c

	HEAP-EXTRACT-MAX(A,n) //返回key最大的元素，同时删除该元素
	if n<0
		error
	swap(A[0],A[n])
	MAX-HEAPFY(A,n-1)//交换后记得重新堆化
	return A[n]
	
	
	HEAP-INCREASE-KEY(A,i,key)//怎加
		if key<A[i]
			error
		else A[i].key = key
	
		while i>=1 && parent(i).key < A[i].key
			swap(parent(i),A[i])
			i = parent(i)
			
	MAX-HEAP-INSERT(A,key,n) //!*
		n=n+1
		A[n]=-∞
		HEAP-INCREASE-KEY(A,n,key)
		
```



## 回溯法

### 01 八皇后问题

**问题描述**

​		略

**实现**

```c
//先放(所有放法)，再判断能否放；这样逻辑比较清晰
	bool QUEEN::PLACE(int k) // k：第k行
		for(int j=0;j<k-1)
			if(x[j]!=x[k] && abs(x[k]-x[j])!=abs(k-j))
				return true
		
	
	bool QUEEN::BACKTRACE(int t)
		if(t>=n-1) sum++
		for(int i=1;i<=n;i++)
			x[t]=i;
			if(PLACE(t))
				BACKTRACE(t+1)
```



### 02 (目标)子集和问题

**问题描述**

​		给定集合，是否存在其子集，其和为S

**问题分析**

​		每个数有两种状态，故搜索树的结构是二叉树，简单回溯时间复杂度 **$O(2^n)$**

​		如果先求SUM数组，两个for循环可以穷举所有可能，时间复杂度：$O(n^2)$

​		**采用分支限界法**

​		可以选择吗：加这个数是否超过s？超过的情况截枝

​		可以选择，要选择吗？不选择，后续的数全部加起来小于s，这个情况截枝；



### 03装载问题

**问题描述**

​		轮船载货，尽量装载

**分析**

​		类似的？一个问题能不能放，能放是放还是不放，是连个独立思考的问题。-通过界限函数B(x)来判定

**实现**

```c
//r-剩下的装载能力、cw-当前装了多少、x[i]={0,1}第i个物品装还是不装、bestw-当前最优解
	void BACKTRACK(int i)
	{
		if(i>n) // 到达叶
			if cw>bestw  bestw=cw ; bestx[]=x[]//bestw和bestx[]作为全局使用
			return ; 
		
		//更新bestx、bestw、return;
		r-=w[i]；
		if(cw+w[i]<=c){ //放，看是否符合能放的条件，同时也是继续往下搜索的条件
			x[i]=1
			cw+=w[i]
			backtrack(i+1）
			cw-w[i];
			
		}
		if(cw+r>bestw){//不放，需要考虑要不要继续下搜；r在前面已经先减去该物件了
			x[i]=0;
			backtrack(i+1);//搜索右子树
		}
	r+=w[i]
	
	}	
```



### 04 批处理作业调度问题-回溯法

**问题**

​		<img src="%E7%AE%97%E6%B3%95.assets/image-20210113220915343.png" alt="image-20210113220915343" style="zoom:67%;" />

​		作业需先由1执行，然后才能由2执行；求最快的作业完成时间

**分析**		

​		**回溯搜索的空间树是一颗排列树**；确定了作业完成的次序-时间也就可以计算；
​		时间怎么计算？总时间就是，每个作业在机器2上完成时间的累加；次序已经被决定
​		需要判定的是：被执行作业在机器2上的完成时间=max(上一个作业在机器2的完成时间，该作业在机器1的完成时间)+该作业在机器2执行所需时间

​		活动选择的动态规划方程
​		**c[i,j]=max{c[i,k]+c[k,j]+1}？** 
​		对于活动选择问题，贪心可以得到最优-选择活动越早结束的活动
​		假定先对所有活动按照活动结束时间的早晚排好序
​		if cf>bestf ，即用时已经超过最优时间，则剪枝-不用递归到下一层了；不管是递归到下一层，还是直接到该层的下一种情况，都需要回溯
​		算法用来穷举排列组合的可能情况的方法比较巧妙，x[]是动态维护的：
​		初始：x[]={1,2,3}; 
​		for:用来穷举该层可选的排列
​		x[t]-当前层的选择，x[t]前面的是确定的；swap(x[t],x[j])-存在自己和自己交换的情况，比如一开始就是swap(x[1],x[1])，这也是刚开始看代码容易混淆x[]的功能的情况
​		

**实现**

```c
//变量和数据结构
//m[j][i] 作业j在机器i上的执行时间
//x[] 当前作业的调度顺序-一种排列情况-动态维护
//f1 机器1完成处理时间 ；f2 机器2完成处理时间
//cf 累计完成时间和
//bestf 记录最优cf
//bestx[] 记录最优作业排列
	
	TRACE-Flowshop(n,m[][])
		TRACE-BACKTRACK(t,n)
			if(t>n)
				if(cf<bestcf) //需要更新
					bestcf = cf
					for i tp n
						bestx[i]=x[i]
			
			for(i=t,i<=n;i++) //探索这层所有作业可能
			{
				f1 = f1+ m[x[i]][1]
				temp = f2
				f2 = max{f1,f2}+m[x[i]][2]
				cf=f2
				if(cf < bestf)
					swap(x[t],x[i]) //可以保障 i》t
					TRACE-BACKTRACK(t+1,n)
					swap(x[t],x[i])//回溯；开始是自己和自己交换
					
				//直接回溯-cf>bestf
				f1-=m[x[i]][1]
				cf-=f2
				f2=tempf
			}		
```

​		

## 贪心问题

### 01 活动选择问题

**问题**

​		给出活动集，包括活动的起始时间和结束时间；可以根据某种贪心原则计算活动全部执行完需要多少时间。

```c
	//贪心非递归实现
	GREEDY-ACTIVITY-SELECTOR(s,f)//活动的开设时间、结束时间数组(按结束时间排好序)
		n = s.length
		A={a1}
		k=1
		for i=2 upto n
			if s[i] >= f[k]
			A=A ∪ A[i]
			k=i
		return A
		
	RECURSIVE-ACTIVITY-SELECTOR(s,f,k,n) //增加虚拟活动a0,结束时间为0；初始调用 RECURSIVE-ACTIVITY-SELECTOR(s,f,0,n)
		
		m=k+1
		while m<=n && s[m]<f[k]
			m++;
		
		if m<=n
			return a[m] ∪ RECURSIVE-ACTIVITY-SELECTOR(s,f,m,n)
		else return 
		
```



## 动态规划

首先，需要原问题具有最优子结构。

通过一步操作将原问题转化为通过求最优子问题可解的情况。求解原问题时我们先假设最优子问题存在。当问题足够小，可解。

动态规划是一种（逻辑上）“查表”的方法，表中存储了已知的最优子问题。

### 01 切杆问题

r[n]表示长度为k的木杆切割可得的最大收益
p[i]保持长度为i的木杆的收益。假定我刀切在 k 处：r[n]=max{p[k]+r[n-k]}

```c
//递归
	CUT-ROD-AUX(p,n) //n-待切杆的长度；p-木杆价格表
		if n==0 return 0 //* 注意这个边界是0；
		
		q=-∞//q 代表长度n的杆所能获得的最大切割收益
		
		for(int i=1;i<n；i++)
			q=max{(q,p[i]+CUR-ROD(p,n-i))}
	
		return q 
```

```c
//带备忘-记忆的递归，保存所有长度切割的最优解
	MEMORIZED-CUT-ROD(p,n)
		for i=0 upto n
			r[n]=-∞
		
	MEMORIZED-CUT-ROD-AUX(p,n,r)
		if(r[n]!=-∞) return q=r[n]
		if n==0 return q=0 
		
		for(int i=1;i<=n;i++)
			//q=max{(q,p[i]+MEMORIZED-CUT-ROD-AUX(p,n-i,r))} //不带切割路径
			if(p[i]+MEMORIZED-CUT-ROD-AUX(p,n-i,r)>=q) //修改为保存切割路径
				cutin = i;
				q=p[i]+MEMORIZED-CUT-ROD-AUX(p,n-i,r)
			
		
		p[n]=cutin; //长度为n的木杆从cutin处切割可得最优解
		r[n]=q;
		return q；
```

```c
//非递归-自底向上方法
	BOTTOM-UP-CUT-ROD(p,n)
		for(int i=1;i<=n;i++)
			q=-∞
			for(j=1;j<=i/2;j++)
				q=max(q,p[j]+r[i-j])
			r[i]=q
	return r[n]
```



### 02 **背包问题**

**问题描述**

​		关于背包问题有几个问题需要理解清楚。有助于我们得出、理解动态方程。

​		子问题是什么？是更少的物品，还是更少的容量？答案是更少的物品；设想一个小偷去商场偷东西。如过商品很少，那么对他来说，偷的方案很好做；所以我们应该力求让物品减少

​		另外，学习一个动态规划算法，要掌握表的解构，查找方法；如何打印解的求解路径。

```c
//问题定义-动态规划方程
		n物、w[i]、v[i]、c、定义c[i,j]表示前i个物品在容量为j的最优价值和
		c[i,j]=c[i-1,j] // w[i]>j ，不能放
		c[i,j]=max{ //能放
			c[i-1,j-w[i])+v[i] , //放
			c[i-1,j] //不放
		}
		v[0,j]=v[i,0]=0;
```

```c
//背包实现-递归
	0-1 BAG(w,v,n,G,c[][])
			if(n==0) return c[0][c]=0;
			if(Gq
			
			if(G<w[n])//不能放
				c[n][G]=BAG(w,v,n-1,G,c[n-1][G])
			else
				c[n][G]=max{BAG(w,v,n-1,G-w[n],c[n-1][G-w[n]])+v[n],
					BAG(w,v,n-1,G,c[n-1][G])}
	
```

```c
//背包实现-非递归	
//动规的非递归算法，就是从底向上填表的过程；
		BAG(w,v,G,c[][])
		for i=0 upto n //假设重量都是整数
			c[i][0]=0;
		for j=0 upto G
			c[j][0]=0;
		
			for(int i=0;i<=n;i++)
				for(int j=0;j<=G;j++)
					if(w[i]<j)//可以放
						c[i][j]=max(c[i-1][j-w[i]]+v[i],c[i-1][j])
					else
						c[i][j]=c[i-1][j]
```



### 03 矩阵链乘问题

**问题描述**

对同一链乘矩阵，加上扩号不改变运行结果，但计算效率却可能相差巨大。

比较难的是对矩阵链乘问题的抽象；

```c
矩阵Ai的维数是pi-1 * pi
	min[i,j]=min[i,k]+min[k+1,j]+pi-1*pk*pj // (Ai*..Ak)(...Aj)
	m[1...n,1,...n]保存代价
	s[1,...,n-1,2,...,n]记录最优值m[i,j]对应的分割点;对应需要切割的情况的取值范围
	将k记录在s[i][j]=k;
	p是一个序列：p=<p0,p1,...,pn>
```



```c
//自底向上方法
	MATRIX-CHAIN-ORDER(p)
		n=p.length-1 //因为数组从0开始计
		let m[][],s[][] be new array
		for(int i=0;i<=n;i++)
			m[i][j]=0;
		for(l=2;l<=n;l++)	//l表示矩阵链的长度；自底向上，我们先求解最短链的最优解，才能逐步向上求解
			for(int i=0;i<=n-l+1;i++) //i-标识该链的起始点矩阵
				j=i+l-1;	//j-该链的最后一个矩阵下标
				m[i][j]=-∞
				for(int k=i;k<=j;k++)
					q=m[i][k]+m[k+1][j]+pi-1*pk*pj
					if(q<m[i][j])
						m[i][j]=q
						s[i][j]=k
		
		return m,s
```

```c
//构造输出最优解
	PRINT-OPTIMAL-PARENS(s,i,j) //paren:圆括号
	if(i==j) Print "A";
	
	printf("(")
	PRINT-OPTIMAL-PARENS(s,i,s[i][j])
	PRINT-OPTIMAL-PARENS(s,s[i,j]+1,j)
	printf(")")
	
```

```c
//递归方法；不带备忘的做法；递归树中相同的子问题，总是重复分解计算
	MATRIX-CHAIN(p,i,j)//把m[][] ,s[][]作为全局来使用
		if(i==j) return m[i][j]=0
		else
			m[i][j]=∞
			for k=i to j-l
				q=MATRIX-CHAIN(p,i,k)+MATRIX-CHAIN(p,k+l,j)+p_i-1 *p_k *p_j 
				if q<m[i][j]
				m[i][j]=q
				s[i][j]=t+l
			
			return m,s；
```

```c
//带备忘递归-课本分成两个；把m[][]初始化为∞抽出来
	MATRIX-CHAIN(p,i,j)
		if(i==j) return m[i][j]=0 
		
		if m[i][j]！= ∞ 
			return m[i][j] // 假设m[][]初始化为∞
		                       
			for k=i to j-l
				q=MATRIX-CHAIN(p,i,k)+MATRIX-CHAIN(p,k+l,j)+p_i-1 *p_k *p_j 
				if q<m[i][j]8ji8j
				m[i][j]=q
				s[i][j]=t+l
			
			return m,s；
```



### 04 最长公共子序列问题LCS

​	X=<x1,..,xm>
​	Y=<y1,...,yn>
​	Z=<z1,...,zk>
​	**子序列的定义**；

```c
 c[i,j]表示长度为i,j的两个子序列的 LCS 的长度
		 c[i,j]=c[i-1,j-1]+1 ; xm=yn
		 c[i,j]=max{c[i-1,j],c[i,j-1]}
		 c[0,1]=0
		 c[1,0]=0
		 c[0,0]=0
		 
```

```c
//自底向上
	LCS-LENGTH(X,Y)
		for i=0 to m
			c[i,0]=0
		for j=0 to n
			c[0,j]=0
		
		for i=1 to X.length
			for j=1 to Y.length
				if(X[i]==Y[j])
					c[i,j]=c[i-1,j-1]+1
				else
					c[i,j]=max{c[i-1,j],c[i,j-1]}
		
		return c;
```

```c
//自底向上+路径保存
	//自底向上
	LCS-LENGTH(X,Y)
		for i=0 to m
			c[i,0]=0
		for j=0 to n
			c[0,j]=0
		
		for i=1 to X.length
			for j=1 to Y.length
				if(X[i]==Y[j])
					c[i,j]=c[i-1,j-1]+1
					b[i,j]="左上箭头"
				else if c[i-1,j]>c[i,j-1]
					c[i,j]=c[i-1,j]
					b[i,j]="左箭头" //假设表i是表示第i行;j表示第j列；左上是原点[0,0]； 怎么保存打印取决于表
				else 
					c[i,j]=c[i,j-1]
					b[i,j]="上箭头"
		
		return c，b;
```

```c
//递归打印(构造)LCS
	PRINT-LCS(b,X,i,j) //起始调用 PRINT-LCS(b,X,X.length,Y.length); 只需要寻找X的最长子序列轨迹
		if(i=0||j==0) return 0
		
		if(b[i][j]="左上箭头")
			PRINT-LCS(b,X,i-1,j-1)
			//print"左上箭头" //不用打箭头，只打序列
			print x[i]	// 只有这种情况是公共的子序列！需要打印
		else if(b[i][j]="上箭头")
			PRINT-LCS(b,X,i-1,j)
			//printf(x[i])
		else
			PRINT-LCS(b,X,i,j-1)
```

	/*实际上可以不用表b；因为每次可以通过查表c中 c[i-1，j-1]、c[i-1,j]、c[i,j-1]三个值，
	在O(1)判断出在计算c[i,j]时使用了哪一项，等价于查表b
	三者谁大取谁；优先取c[i-1,j-1]
	*/


## 图算法

### DFS 算法

算法导论中，将图的路径抽象为“树边、前向边、反向边，交叉边”等概念，来描述DFS蒜贩的特征和性质。

**边的分类**：DFS时，边第一次执行（u,v）v的颜色决定了边的类型

基本图的DFS算法：由 DFS(G) 和 DFS-VISIT(G,s)

```c
//深度优先搜索;邻接表
	DFS-VISIT(G,s) // G-无向图、s为根 ;从给定根做一次DFS搜索-相当于树的情况
		time+=1;  // *！进来之前，结点一定是white
		s.color = grey;
		s.st = time;
		
		for each v belong adj[s]
			if(v.color == white)
				v.p = s
				BFS(G,v)
			if(v.color == grey) //无向图只有反向边(指向祖先结点) 和 树边 ； 无前向边（指向后代-非树边）
				print"有环" //注意有环判断的时间复杂度0(|V|),这个代码可以实现有环判定，但实际如果要判定无向图是否有环，可以更快；一次DFS-VISIT算法在发现环之前，最多只会遍历|v|条边
		v.color = black;
		time+=1;// *！每次遍历完一个结点的全部邻接结点，回溯时间要+1；从结构看，因为是DFS，越深的结点是先遍历完的
		v.ft = time; 
```

### DFS求连通图个数

```c
//求有多少个连通图
	DFS(G)
		for all v belong G.V
			v.color = white
			v.p = null; //父亲结点
			v.st = 0;
			v.ft = ∞;
		for all v belong G.V
			if(v.color == White)
				num++;
				BFS-VISIT(G,v)
```

### DFS应用

​	01-无限图G是否连通问题？调用一次DFS-VISIT,如果还有结点是WHITE,则不连通	; O(|V|+|E|)
​	02-寻找无向图连通分支？每执行一次DSF-VISIT得到1个连通分支；可以再增加数组为每个结点做标记；在num++处，满足black 且 标记为0，为一个连通；收集并标记为1 ; O(|V|+|E|)
​	03-无向图G是否是1棵树？注意是树，不包括森林；那么看由美亚反向边-成环则不是； 看是不是森林-连通吗； O(|v|)

```c
//深度优先搜索;有向图-邻接表(可能存在前向边-画出图好理解； 交叉边)
	DFS-VISIT(G,s) // G-有向图、s为根 ;从给定根做一次DFS搜索-相当于树的情况
		time+=1;  // *！进来之前，结点一定是white
		s.color = grey;
		s.st = time;
		
		for all v = adj[s]
			if(v.color == white)
				v.p = s
				BFS(G,v)
			if(v.color == grey) //无向图只有反向边(指向祖先结点) 和 树边 ； 无前向边（祖先指向后代-非树边）
				print"有环"
		v.color = black;
		time+=1;// *！每次遍历完一个结点的全部邻接结点，回溯时间要+1；从结构看，因为是DFS，越深的结点是先遍历完的
		v.ft = time; 
	
	//成不成环问题，与无向图的处理方法是一样的
```



### DFS解强连通图问题

求有多少个强连通图（连通性问题）-不能按照无向图的方法了
	强连通图问题：
		**01-做一遍DFS(G)算法；**
		**02-将G转置得GT(V,ET)**
		**根据02，根据|V|中结点v.ft的顺序**
		**在GT(V,ET)中执行 DFS-VISIT算法；每次挑还是白色的结点；**
		**每次DFS-VISIT得到的就是有向图的1个连通图**



### DFS-拓扑排序

```c
//其它应用
	拓扑排序-利用DFS做：
		0a-当一个结点DFS访问结束，添加到链表中，最后返回链表
		0b-对结点按访问结束时间从大到小输出，就是1个拓扑排序
		O(|V|+|E|)
		
```

### BFS算法

广度优先搜索BFS
基本思想：先找距离源点距离为k的结点，再找距离(k+1)的结点

```c
BFS(G) // 以为s为根
			for all v belong |V|
				v.color = white
				v.p = null;
				v.d = ∞;
			
			for(all v belong |V|)
				if v.color = white
					v.d = 0
					BFS-VISIT(G,v)
		
```

```c
			
	BFS-VISIT(G,r) // 以r为根 ; 求s-t距离；直接调用BFS-VISIT(G,s) //然后再对代码做小小修改
			r.color = grey
			Q.ENQUEUE(r)
			
			while Q.isEMPTY==false
				u=Q.DEQUEUE
				visist"u"
				for all v belong to G.adj[u]
					if(v.color == white)
						v.d=u.d+1;
						v.p=u
						v.color = grey
						Q.ENQUEUE(v)
				
				u.color = black
			
			return G
```

通过BFS可以得到：
		从某点出发到其它结点的最短路径
		以s为根的BFS树（前提是不成环、连通，求一个连通子图，有结点被指定为根）
		邻接表存储图，BFS算法时间复杂度为 O(|V|+|E|); 若是邻接矩阵，则为O(|V|^2)

### 最小生成树算法（Kruskal和 Prime）

**思想**

每次从未选边集选不成环的边；(算法结束，是否包括所有点，是则成功)一般对象是连通的（无向图）

01-初始化：每个结点为1个连通分支
02-对于两个连通分支，选择他们的权值最小的边，合并这两个连通分支，重复这一过程
		利用并查集：MAKE-SET(v) 、FIND-SET(v) 、UNION(u,v) 
		输入：加权连通图
		输出ET

```c
MST-KRUSAL(G,w) //w保存了边的权重信息
			for v belong to all G.V
				MAKE-SET(v)
				
			sort the G.E in increasing order using input w 
			
			for each (u,v) belong to G.E
				if FIND-SET(u)!=FIND-SET(v)
					UNION-SET(u,v)  //最高时间复杂度可以达到 O(|lgV|)
					A=A∪{(u,v)} // A保存边集
			
			return A
			
		//时间复杂度：O(|E|lg|V|)
```

**相关算法：并查集**

```c
并查集由一个个不相交（领主不同）的集合构成S={S1,S2,...,Sk}
		具有3个操作
			MAKE-SET(x): Si={x}，S=S∪{x}  //O(1)
			FIND-SET(x)	//O(1)
			UNION(x,y)  //O(n)
		//基于并查集求无向图中所有连通分支-对比DFS方法\BFS方法
		CONNECTED-COMPONENTS(G)
			for each v belong to G.V
				MAKE-SET(v)
			for each edge (u,v) belong to G.E
				if(FIND-SET(u)==FIND-SET(v))
					UNION(u,v)
			count how many SET in S //统计S中有多少个集合就可知有多少个连通图
			
		//实现并查集的数据结构设计，可以用链表实现；
```



### Prime算法

**思想：**

01-创建一颗局部树VA并不断增长
02-每次选一条权值最小的边(选边也是选点)，这条边要连接局部树和未在局部树(V-VA)中的结点

**分析:**

01-使用数据结构"优先队列-Q"来实现（上面已总结）
02-优先队列元素是结点,属于{V-VA}，记为v；局部树{VA}结点记为(u,v)
	  优先队列基于最小堆实现，每个元素(结点)的key值是v到u中所有边中权值最小那条边的权值
03-EXTRACT-MIN(Q) 表示从Q中取出当前key最小的结点

```c
PRIM(G,w,r) //w 保存了每条边的权值
			Q=空集合 // Q用来表示一个最小优先队列
			for each v belong G.V
				v.p = null //指向结点在生成树中的父结点- 用来保存"MST"结构信息的
				v.key = ∞
				Q.insert(v)
			DECREASE-KEY(Q,r,0)	// 选择图中一个节点r,将其key置为0，则r默认为MST-TREE的根 ； 所以r 已知！
			while Q.isEMPTY ==false 
				u = EXTRACT-MIN(Q) // EXTRACT-MIN(Q): 1-取Q中key最小元素(第；2- 将u从Q删除 ； 根据上面，第一次取的是r
				for each v belong to G.Adj[u] //看需不需要修改
					if(v belong to Q && w(v,u)<v.key) //因为u已经加入了VA
						v.p = u //常规的邻接表，是没有v.p这个域的 			//Q1:有些结点的指针p不会修改，对吧？
						DECREASE-KEY(Q,v,w(u,v))
						
			
			//时间复杂度：O(|E|lg|V|)
			//Q2：仅靠当前信息，无法很好的还原MST树
```





# OJ

## 树

### 两棵树合并

思路：

可以使用深度优先搜索合并两个二叉树。从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。

两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。

如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；

如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；

如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。

对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过

```` java
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == null) {
            return t2;
        }
        if (t2 == null) {
            return t1;
        }
        TreeNode merged = new TreeNode(t1.val + t2.val);
        merged.left = mergeTrees(t1.left, t2.left);
        merged.right = mergeTrees(t1.right, t2.right);
        return merged;
    }
}
````



### 将有序数组转换为平衡二叉搜索树

题目：给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。



分析：

1.相关性质熟悉。二叉搜索树，左小右大；平衡树的相关概念

2.二叉搜索树的中序遍历是递增的；所以 升序 的nums数组，是要构建的树的中序遍历；

3.给定一棵树的中序遍历，无法唯一确定一棵树。同样，再加上一个限制条件，平衡的二叉搜索树，同样该树是不唯一的，所以答案有多种；

4.以下面的策略，便可构造题目要求的树：从nums数组取出根结点。nums.length 是奇数，呢么根结点是确定，否则，构建的树情况有多种，取决于根结点的选择；eg.[1,3,5,7] 可以选择3为根，也可以选择5为根

5.由于数组是升序的，二叉搜索树左小右大的性质，选出根结点后，便可以递归的构造目标树。

```` java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
//我的题解：
//空间复杂度：会传建子数组，子数组个数2*log(n) ,每个长度O(n)； 所以空间复杂度O（nlog(n)）
//时间复杂度：O(n)； nums数组每个元素被取为root一次

class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        //递归终止条件
        if(nums.length == 1) {
            TreeNode leaf = new TreeNode(nums[0]);
            return leaf; 
        } 
        if(nums.length == 0)  return null;

        int rootNum = nums[nums.length/2];
        TreeNode root = new TreeNode(rootNum);
        int[] lNums = Arrays.copyOfRange(nums,0,nums.length/2); //[start,end) , 所以不用-1
        int[] rNums = Arrays.copyOfRange(nums,nums.length/2+1,nums.length); 
        root.left = sortedArrayToBST(lNums);
        root.right = sortedArrayToBST(rNums);

        return root;

    }
}
//参考题解
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return helper(nums, 0, nums.length - 1);
    }

    public TreeNode helper(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }

        // 总是选择中间位置左边的数字作为根节点
        int mid = (left + right) / 2;

        TreeNode root = new TreeNode(nums[mid]);
        root.left = helper(nums, left, mid - 1);
        root.right = helper(nums, mid + 1, right);
        return root;
    }
}

//时间复杂度：O(n)，其中 n 是数组的长度。每个数字只访问一次。

//空间复杂度：O(\log n)，其中 n是数组的长度。空间复杂度不考虑返回值，因此空间复杂度主要取决于递归栈的深度，递归栈的深度是 //O(\log n)。

````



## 链表

### 反转链表

边界条件的处理



### 合并两个升序链表

**方法一： 暴力合并**

无言。- 。 - 

```` java

class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode preHead = new ListNode(-1);
        ListNode pre = preHead;

        while(l1 != null && l2 != null){
            if(l1.val <= l2.val){
                pre.next = l1;
                pre = l1;
                l1 = l1.next;
            }else{
                pre.next =l2;
                pre = l2 ;
                l2 = l2.next;
            }
        }
        pre.next = l1==null ? l2:l1;
        return preHead.next;
    }
}
````

**方法二: 递归合并**

````java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 ==null && l2 ==null) return null;
        if(l1 == null && l2 !=null ) return l2;
        if(l1 != null && l2 == null) return l1;
        
        if(l1.val<=l2.val){
            l1.next = mergeTwoLists(l1.next,l2);
        }else{
            l2.next = mergeTwoLists(l1,l2.next);
        }
        
        return l1.val<=l2.val ? l1 : l2 ;

      
    }
}
````





## 技巧题

### 寻找数组中只出现一次的数

题目描述：一个数组中 $2m+1$ 个数，m=0，1，2，... ；m个数各出现两次，有一个数只出现1次，求这个数；要求$O(1),O(1)$

**技巧：利用异或计算的性质**

$ a \oplus 0 =a$

$a \oplus a =0$ 

**异或运算有交换律和结合律**



### 多数元素

题目描述：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素

题解算法：

````java
//投票算法
class Solution {
    public int majorityElement(int[] nums) {
        int candidate = nums[0];
        int count=0;
        for(int i=0;i<nums.length;i++){
            if(count == 0){
                candidate =nums[i];
                count++;
            }else{
                if(candidate == nums[i]){
                    count++;
                }else{
                    count--;
                }
            }
        }
        return candidate;

    }
}
//算法正确性证明：https://leetcode-cn.com/problems/majority-element/
//O(1),O(1)
````













#  JAVA细节

```` java
  String.charAt(index)//
````



