## 分治法

### 1-最大子数组问题

**问题描述**

​		给定一个数组，求其最大连续子数组的和

**策略**

​		分治法解,将原问题转化为：比较左子数组的最大子数组、右子数组的最大子数组、跨中间 位置的最大子数组中的最大者，就是原问题的解。通过这样的转化，原问题可以不断划分为小问题。

​		关键是求和理解跨中间最大子数组。跨中间最大子数组并非原问题的最大子数组。它必须要跨中间元素，求解该子问题只需要 **O(n)**的时间复杂度。

**实现**

```c++
//伪代码
//求跨中间元素的最大子数组
FIND-MAX-CROSSING-SUBARRAY(low,high,mid,A) 
	lest-sum = ∞
	sum=0
	for i=mid down to low
		sum+=A[i]
		if sum>left-sum
			left-sum = sum
			max-left=i
	lest-sum = ∞
	sum=0
	for j=mod up to high
		sum+=A[i]
		if sum>right-sum
			right-sum=sum
			max-right=j
	return(max-left,max-right,left-sum+right-sum)
            
//递归求解问题
	
FIND-MAX-SUBARRAY(low,high,A)
	//递归截止条件
	if(low == high) return(low,high,A[low])
		
	mid= Dint((low+high)/2)
	(left-low,left-high,left-sum)=FIND-MAX-SUBARRAY(low,mid,A)
	(right-low,right-high,right-sum)=FIND-MAX-SUBARRY(mid,right,A)
	(cross-low,cross-right,cross-sum)=FIND-MAX-CROSSIN-SUBARRY(low,high,A)
	
	if(left-sum>=cross-sum&&left-sum>=riht-sum) return(left-low,left-high,left-sum)
	if(right-sum>=cross-sum&&riht-sum>=left-sum) return(right-low,riht-high,right-sum)
	if(cross-sum>=left-sum&&cross-sum>=riht-sum) return(cross-low,cross-high,cross-sum)

```

### 2-两个有序数组的中位数问题

**问题描述**		

​		给定两个大小为 m 和 n 的有序数组 A 和 B 。逻辑上归并后的数组为C。请找出C的中位数。要求算法的时间复杂度为 O(log (m+n)) ；

**分析** 

​		要实现这个时间复杂度，用分治法；用最后一步归并方法也可以求解，但时间复杂度是 **O(m+n)**。

​		**一开始的问题：找中位数就是找(归并后)第k个数，k定义如下：**
​		**(len(A)+len(B))为偶**：令k1=(len(A)+len(B))/2 和k2=(len(A)+len(B))/2 +1 个; (C[k]+C[k+1])/2 就是中位数;中位数不一定就要是原来存在的元素，比如元素个数是偶数的时候通过这样求得。
​		**(len(A)+len(B))为奇：**令k=(len(A)+len(B))/2 + 1，C[k]既是
​	但是,这是两个有序数组，**有更好的解法：**
​	还是定义k=(len(A)+len(B))/2
​		令 p=k/2-1,q=k/2(=k-p-1), p+q=k-1;//我们要找第k个数，通过数组特征分解第k-1个数来分解问题
​		对于A[p]、B[q]的较小者，其所在序列的前面部分，肯定不包含目标值(另个不确定哦-这是理解的关键。另一个数组的前面任意一个数，都有可能是要求的数。考虑一个数组元素完全大于另外一个数组的情况)
​		可以抛弃得到子序列！问题规模缩小了！
​		我们先看A[p] B[q]这两个数的大小,可以获得如下信息
​		if A[p] = B[q] , return A[p] 或者B[q]
​		if A[p] < B[q] , 在A[p+1,len(A)] 和 B[0,len(B)]中搜索第k-p个数
​		if A[p] > B[q] , 在A[0,len(A)] 和 B[q+1,len(B)]中搜索第k-q个数



**实现**

```C
//代码实现
		Find-Middle-Element(A,B)
			k=(len(A)+len(B))/2
			if((len(A)+len(B))%2==0)
				return (Find-NoK(A,B,0,len(A)-1,0,len(B)-1,k)+Find-NoK(A,B,0,len(A)-1,0,len(B)-1,k+1))/2
			else return Find-NoK(A,B,0,len(A)-1,0,len(B)-1,k+1)
		
		Find-Nok(A,B,Astart,Aend,Bstart,Bend,k)
			
			if((Aend-Astart)>(Bend-Bstart))
				return Find-Nok(B,A,Bstart,Bend,Astart,Aend,k)//保证len1始终最短-简化下面讨论代码
			if((Astart-Aend)==0) return B[k]
			
			if(k==1) return min(A[start],B[start]) //边界之一；
			p = min(k/2,Aend-Asatrt) //最短的是A数组了，前面简化作用体现出来了
			q=k-q
			if(A[Astatrt+p-1]<B[Bstatrt+q-1]) return(A,B,Astart+p,Aend,Bsatrt,Bend,k-p)
			if(A[Astatrt+p-1]>B[Bstatrt+q-1]) return(A,B,Astart,Aend,Bsatrt+q,Bend,k-q)	
			if(()==()) return A[Astatr+p-1] //想等，这两个一个是k-1,一个是 k，就是我们要找的，直接返回
```



## 堆和堆排序

**基本堆操作**

堆相关的3个操作；注意建堆的渐进紧确界是 **O(n)**

```c
//以A[i]为根，1次自上而下堆化过程
	MAX-HEAPIFY(A,i,n)
		l=LEFT(i)
		r=RIGHT(i)
		if(l>n) return ;
		if(r>n) return ;
		if(A[l]<=A[r]&&A[r]>A[i]) 
			swap(A[i],A[r])
			MAX-HEAPIFY(A,r,n)
		if(A[r]<=A[l]&&A[l]>A[i]) 
			swap(A[i],A[l])
			MAX-HEAPIFY(A,l,n)
			
	//课本版本
	MAX-HEAPIFY(A,i,n)
		l=LEFT(i)
		r=RIGHT(i)
		if(l<=n&&A[l]>A[i])
			largest = l
		else larest = i
		if(r<=n&&A[r]>A[largest])
			largest = r
		if largest!=i
			swap(A[i],A[largest])
			MAX-HEAPIFY(A,largest,n)
	//建堆
	BUILD-MAX-HEAP(A,n)
		for i= Dint(n/2) down to 1
			MAX-HEAPIFY(A,i,n)
	
	//堆排序	
	HEAPSORT(A,n) //递归版本
	if n>=1
		BUILD-MAX-HEAP(A,n)
		swap(A[0],A[n])
		HEAPIFY-SORT(A,n-1)
		
	HEAPSORT(A,n) //非递归版本
		BUILD-MAX-HEAP(A,n)
		for i=n downto 1
		swap(A[0],A[i])
		MAX-HEAPIFY(A,0,i-1)
```



### 基于堆排序的最大优先队列

**基于数据结构的操作描述**

​		用最大堆实现一个最大优先队列
​		最大优先队列，队列每个元素有一个权重key;

​		INSERT(S,x):把元素x插入集合S中
​		MAXIMUM(S):返回S中具有最大关键字的元素
​		EXTRACT-MAX(S)：去掉并返回S中具有最大关键字的元素
​		INCERASE-KEY(S,x,k):将元素x的关键字增加到k;k需要比原来key大

​		显然，最大最小堆是根据key大小来建立的

**实现**

```c

	HEAP-EXTRACT-MAX(A,n) //返回key最大的元素，同时删除该元素
	if n<0
		error
	swap(A[0],A[n])
	MAX-HEAPFY(A,n-1)//交换后记得重新堆化
	return A[n]
	
	
	HEAP-INCREASE-KEY(A,i,key)//怎加
		if key<A[i]
			error
		else A[i].key = key
	
		while i>=1 && parent(i).key < A[i].key
			swap(parent(i),A[i])
			i = parent(i)
			
	MAX-HEAP-INSERT(A,key,n) //!*
		n=n+1
		A[n]=-∞
		HEAP-INCREASE-KEY(A,n,key)
		
```



## 回溯法

### 01 八皇后问题

**问题描述**

​		略

**实现**

```c
//先放(所有放法)，再判断能否放；这样逻辑比较清晰
	bool QUEEN::PLACE(int k) // k：第k行
		for(int j=0;j<k-1)
			if(x[j]!=x[k] && abs(x[k]-x[j])!=abs(k-j))
				return true
		
	
	bool QUEEN::BACKTRACE(int t)
		if(t>=n-1) sum++
		for(int i=1;i<=n;i++)
			x[t]=i;
			if(PLACE(t))
				BACKTRACE(t+1)
```



### 02 (目标)子集和问题

**问题描述**

​		给定集合，是否存在其子集，其和为S

**问题分析**

​		每个数有两种状态，故搜索树的结构是二叉树，简单回溯时间复杂度 **$O(2^n)$**

​		如果先求SUM数组，两个for循环可以穷举所有可能，时间复杂度：$O(n^2)$

​		**采用分支限界法**

​		可以选择吗：加这个数是否超过s？超过的情况截枝

​		可以选择，要选择吗？不选择，后续的数全部加起来小于s，这个情况截枝；



### 03装载问题

**问题描述**

​		轮船载货，尽量装载

**分析**

​		类似的？一个问题能不能放，能放是放还是不放，是连个独立思考的问题。-通过界限函数B(x)来判定

**实现**

```c
//r-剩下的装载能力、cw-当前装了多少、x[i]={0,1}第i个物品装还是不装、bestw-当前最优解
	void BACKTRACK(int i)
	{
		if(i>n) // 到达叶
			if cw>bestw  bestw=cw ; bestx[]=x[]//bestw和bestx[]作为全局使用
			return ; 
		
		//更新bestx、bestw、return;
		r-=w[i]；
		if(cw+w[i]<=c){ //放，看是否符合能放的条件，同时也是继续往下搜索的条件
			x[i]=1
			cw+=w[i]
			backtrack(i+1）
			cw-w[i];
			
		}
		if(cw+r>bestw){//不放，需要考虑要不要继续下搜；r在前面已经先减去该物件了
			x[i]=0;
			backtrack(i+1);//搜索右子树
		}
	r+=w[i]
	
	}	
```



### 04 批处理作业调度问题-回溯法

**问题**

​		<img src="%E7%AE%97%E6%B3%95.assets/image-20210113220915343.png" alt="image-20210113220915343" style="zoom:67%;" />

​		作业需先由1执行，然后才能由2执行；求最快的作业完成时间

**分析**		

​		**回溯搜索的空间树是一颗排列树**；确定了作业完成的次序-时间也就可以计算；
​		时间怎么计算？总时间就是，每个作业在机器2上完成时间的累加；次序已经被决定
​		需要判定的是：被执行作业在机器2上的完成时间=max(上一个作业在机器2的完成时间，该作业在机器1的完成时间)+该作业在机器2执行所需时间

​		活动选择的动态规划方程
​		**c[i,j]=max{c[i,k]+c[k,j]+1}？** 
​		对于活动选择问题，贪心可以得到最优-选择活动越早结束的活动
​		假定先对所有活动按照活动结束时间的早晚排好序
​		if cf>bestf ，即用时已经超过最优时间，则剪枝-不用递归到下一层了；不管是递归到下一层，还是直接到该层的下一种情况，都需要回溯
​		算法用来穷举排列组合的可能情况的方法比较巧妙，x[]是动态维护的：
​		初始：x[]={1,2,3}; 
​		for:用来穷举该层可选的排列
​		x[t]-当前层的选择，x[t]前面的是确定的；swap(x[t],x[j])-存在自己和自己交换的情况，比如一开始就是swap(x[1],x[1])，这也是刚开始看代码容易混淆x[]的功能的情况
​		

**实现**

```c
//变量和数据结构
//m[j][i] 作业j在机器i上的执行时间
//x[] 当前作业的调度顺序-一种排列情况-动态维护
//f1 机器1完成处理时间 ；f2 机器2完成处理时间
//cf 累计完成时间和
//bestf 记录最优cf
//bestx[] 记录最优作业排列
	
	TRACE-Flowshop(n,m[][])
		TRACE-BACKTRACK(t,n)
			if(t>n)
				if(cf<bestcf) //需要更新
					bestcf = cf
					for i tp n
						bestx[i]=x[i]
			
			for(i=t,i<=n;i++) //探索这层所有作业可能
			{
				f1 = f1+ m[x[i]][1]
				temp = f2
				f2 = max{f1,f2}+m[x[i]][2]
				cf=f2
				if(cf < bestf)
					swap(x[t],x[i]) //可以保障 i》t
					TRACE-BACKTRACK(t+1,n)
					swap(x[t],x[i])//回溯；开始是自己和自己交换
					
				//直接回溯-cf>bestf
				f1-=m[x[i]][1]
				cf-=f2
				f2=tempf
			}		
```

​		

## 贪心问题

### 01 活动选择问题

**问题**

​		给出活动集，包括活动的起始时间和结束时间；可以根据某种贪心原则计算活动全部执行完需要多少时间。

```c
	//贪心非递归实现
	GREEDY-ACTIVITY-SELECTOR(s,f)//活动的开设时间、结束时间数组(按结束时间排好序)
		n = s.length
		A={a1}
		k=1
		for i=2 upto n
			if s[i] >= f[k]
			A=A ∪ A[i]
			k=i
		return A
		
	RECURSIVE-ACTIVITY-SELECTOR(s,f,k,n) //增加虚拟活动a0,结束时间为0；初始调用 RECURSIVE-ACTIVITY-SELECTOR(s,f,0,n)
		
		m=k+1
		while m<=n && s[m]<f[k]
			m++;
		
		if m<=n
			return a[m] ∪ RECURSIVE-ACTIVITY-SELECTOR(s,f,m,n)
		else return 
		
```



## 动态规划

首先，需要原问题具有最优子结构。

通过一步操作将原问题转化为通过求最优子问题可解的情况。求解原问题时我们先假设最优子问题存在。当问题足够小，可解。

动态规划是一种（逻辑上）“查表”的方法，表中存储了已知的最优子问题。

### 01 切杆问题

r[n]表示长度为k的木杆切割可得的最大收益
p[i]保持长度为i的木杆的收益。假定我刀切在 k 处：r[n]=max{p[k]+r[n-k]}

```c
//递归
	CUT-ROD-AUX(p,n) //n-待切杆的长度；p-木杆价格表
		if n==0 return 0 //* 注意这个边界是0；
		
		q=-∞//q 代表长度n的杆所能获得的最大切割收益
		
		for(int i=1;i<n；i++)
			q=max{(q,p[i]+CUR-ROD(p,n-i))}
	
		return q 
```

```c
//带备忘-记忆的递归，保存所有长度切割的最优解
	MEMORIZED-CUT-ROD(p,n)
		for i=0 upto n
			r[n]=-∞
		
	MEMORIZED-CUT-ROD-AUX(p,n,r)
		if(r[n]!=-∞) return q=r[n]
		if n==0 return q=0 
		
		for(int i=1;i<=n;i++)
			//q=max{(q,p[i]+MEMORIZED-CUT-ROD-AUX(p,n-i,r))} //不带切割路径
			if(p[i]+MEMORIZED-CUT-ROD-AUX(p,n-i,r)>=q) //修改为保存切割路径
				cutin = i;
				q=p[i]+MEMORIZED-CUT-ROD-AUX(p,n-i,r)
			
		
		p[n]=cutin; //长度为n的木杆从cutin处切割可得最优解
		r[n]=q;
		return q；
```

```c
//非递归-自底向上方法
	BOTTOM-UP-CUT-ROD(p,n)
		for(int i=1;i<=n;i++)
			q=-∞
			for(j=1;j<=i/2;j++)
				q=max(q,p[j]+r[i-j])
			r[i]=q
	return r[n]
```



### 02 **背包问题**

**问题描述**

​		关于背包问题有几个问题需要理解清楚。有助于我们得出、理解动态方程。

​		子问题是什么？是更少的物品，还是更少的容量？答案是更少的物品；设想一个小偷去商场偷东西。如过商品很少，那么对他来说，偷的方案很好做；所以我们应该力求让物品减少

​		另外，学习一个动态规划算法，要掌握表的解构，查找方法；如何打印解的求解路径。

```c
//问题定义-动态规划方程
		n物、w[i]、v[i]、c、定义c[i,j]表示前i个物品在容量为j的最优价值和
		c[i,j]=c[i-1,j] // w[i]>j ，不能放
		c[i,j]=max{ //能放
			c[i-1,j-w[i])+v[i] , //放
			c[i-1,j] //不放
		}
		v[0,j]=v[i,0]=0;
```

```c
//背包实现-递归
	0-1 BAG(w,v,n,G,c[][])
			if(n==0) return c[0][c]=0;
			if(Gq
			
			if(G<w[n])//不能放
				c[n][G]=BAG(w,v,n-1,G,c[n-1][G])
			else
				c[n][G]=max{BAG(w,v,n-1,G-w[n],c[n-1][G-w[n]])+v[n],
					BAG(w,v,n-1,G,c[n-1][G])}
	
```

```c
//背包实现-非递归	
//动规的非递归算法，就是从底向上填表的过程；
		BAG(w,v,G,c[][])
		for i=0 upto n //假设重量都是整数
			c[i][0]=0;
		for j=0 upto G
			c[j][0]=0;
		
			for(int i=0;i<=n;i++)
				for(int j=0;j<=G;j++)
					if(w[i]<j)//可以放
						c[i][j]=max(c[i-1][j-w[i]]+v[i],c[i-1][j])
					else
						c[i][j]=c[i-1][j]
```



### 03 矩阵链乘问题

**问题描述**

对同一链乘矩阵，加上扩号不改变运行结果，但计算效率却可能相差巨大。

比较难的是对矩阵链乘问题的抽象；

```c
矩阵Ai的维数是pi-1 * pi
	min[i,j]=min[i,k]+min[k+1,j]+pi-1*pk*pj // (Ai*..Ak)(...Aj)
	m[1...n,1,...n]保存代价
	s[1,...,n-1,2,...,n]记录最优值m[i,j]对应的分割点;对应需要切割的情况的取值范围
	将k记录在s[i][j]=k;
	p是一个序列：p=<p0,p1,...,pn>
```



```c
//自底向上方法
	MATRIX-CHAIN-ORDER(p)
		n=p.length-1 //因为数组从0开始计
		let m[][],s[][] be new array
		for(int i=0;i<=n;i++)
			m[i][j]=0;
		for(l=2;l<=n;l++)	//l表示矩阵链的长度；自底向上，我们先求解最短链的最优解，才能逐步向上求解
			for(int i=0;i<=n-l+1;i++) //i-标识该链的起始点矩阵
				j=i+l-1;	//j-该链的最后一个矩阵下标
				m[i][j]=-∞
				for(int k=i;k<=j;k++)
					q=m[i][k]+m[k+1][j]+pi-1*pk*pj
					if(q<m[i][j])
						m[i][j]=q
						s[i][j]=k
		
		return m,s
```

```c
//构造输出最优解
	PRINT-OPTIMAL-PARENS(s,i,j) //paren:圆括号
	if(i==j) Print "A";
	
	printf("(")
	PRINT-OPTIMAL-PARENS(s,i,s[i][j])
	PRINT-OPTIMAL-PARENS(s,s[i,j]+1,j)
	printf(")")
	
```

```c
//递归方法；不带备忘的做法；递归树中相同的子问题，总是重复分解计算
	MATRIX-CHAIN(p,i,j)//把m[][] ,s[][]作为全局来使用
		if(i==j) return m[i][j]=0
		else
			m[i][j]=∞
			for k=i to j-l
				q=MATRIX-CHAIN(p,i,k)+MATRIX-CHAIN(p,k+l,j)+p_i-1 *p_k *p_j 
				if q<m[i][j]
				m[i][j]=q
				s[i][j]=t+l
			
			return m,s；
```

```c
//带备忘递归-课本分成两个；把m[][]初始化为∞抽出来
	MATRIX-CHAIN(p,i,j)
		if(i==j) return m[i][j]=0 
		
		if m[i][j]！= ∞ 
			return m[i][j] // 假设m[][]初始化为∞
		                       
			for k=i to j-l
				q=MATRIX-CHAIN(p,i,k)+MATRIX-CHAIN(p,k+l,j)+p_i-1 *p_k *p_j 
				if q<m[i][j]8ji8j
				m[i][j]=q
				s[i][j]=t+l
			
			return m,s；
```



### 04 最长公共子序列问题LCS

​	X=<x1,..,xm>
​	Y=<y1,...,yn>
​	Z=<z1,...,zk>
​	**子序列的定义**；

```c
 c[i,j]表示长度为i,j的两个子序列的 LCS 的长度
		 c[i,j]=c[i-1,j-1]+1 ; xm=yn
		 c[i,j]=max{c[i-1,j],c[i,j-1]}
		 c[0,1]=0
		 c[1,0]=0
		 c[0,0]=0
		 
```

```c
//自底向上
	LCS-LENGTH(X,Y)
		for i=0 to m
			c[i,0]=0
		for j=0 to n
			c[0,j]=0
		
		for i=1 to X.length
			for j=1 to Y.length
				if(X[i]==Y[j])
					c[i,j]=c[i-1,j-1]+1
				else
					c[i,j]=max{c[i-1,j],c[i,j-1]}
		
		return c;
```

```c
//自底向上+路径保存
	//自底向上
	LCS-LENGTH(X,Y)
		for i=0 to m
			c[i,0]=0
		for j=0 to n
			c[0,j]=0
		
		for i=1 to X.length
			for j=1 to Y.length
				if(X[i]==Y[j])
					c[i,j]=c[i-1,j-1]+1
					b[i,j]="左上箭头"
				else if c[i-1,j]>c[i,j-1]
					c[i,j]=c[i-1,j]
					b[i,j]="左箭头" //假设表i是表示第i行;j表示第j列；左上是原点[0,0]； 怎么保存打印取决于表
				else 
					c[i,j]=c[i,j-1]
					b[i,j]="上箭头"
		
		return c，b;
```

```c
//递归打印(构造)LCS
	PRINT-LCS(b,X,i,j) //起始调用 PRINT-LCS(b,X,X.length,Y.length); 只需要寻找X的最长子序列轨迹
		if(i=0||j==0) return 0
		
		if(b[i][j]="左上箭头")
			PRINT-LCS(b,X,i-1,j-1)
			//print"左上箭头" //不用打箭头，只打序列
			print x[i]	// 只有这种情况是公共的子序列！需要打印
		else if(b[i][j]="上箭头")
			PRINT-LCS(b,X,i-1,j)
			//printf(x[i])
		else
			PRINT-LCS(b,X,i,j-1)
```

	/*实际上可以不用表b；因为每次可以通过查表c中 c[i-1，j-1]、c[i-1,j]、c[i,j-1]三个值，
	在O(1)判断出在计算c[i,j]时使用了哪一项，等价于查表b
	三者谁大取谁；优先取c[i-1,j-1]
	*/


## 图算法

### DFS 算法

算法导论中，将图的路径抽象为“树边、前向边、反向边，交叉边”等概念，来描述DFS蒜贩的特征和性质。

**边的分类**：DFS时，边第一次执行（u,v）v的颜色决定了边的类型

基本图的DFS算法：由 DFS(G) 和 DFS-VISIT(G,s)

```c
//深度优先搜索;邻接表
	DFS-VISIT(G,s) // G-无向图、s为根 ;从给定根做一次DFS搜索-相当于树的情况
		time+=1;  // *！进来之前，结点一定是white
		s.color = grey;
		s.st = time;
		
		for each v belong adj[s]
			if(v.color == white)
				v.p = s
				BFS(G,v)
			if(v.color == grey) //无向图只有反向边(指向祖先结点) 和 树边 ； 无前向边（指向后代-非树边）
				print"有环" //注意有环判断的时间复杂度0(|V|),这个代码可以实现有环判定，但实际如果要判定无向图是否有环，可以更快；一次DFS-VISIT算法在发现环之前，最多只会遍历|v|条边
		v.color = black;
		time+=1;// *！每次遍历完一个结点的全部邻接结点，回溯时间要+1；从结构看，因为是DFS，越深的结点是先遍历完的
		v.ft = time; 
```

### DFS求连通图个数

```c
//求有多少个连通图
	DFS(G)
		for all v belong G.V
			v.color = white
			v.p = null; //父亲结点
			v.st = 0;
			v.ft = ∞;
		for all v belong G.V
			if(v.color == White)
				num++;
				BFS-VISIT(G,v)
```

### DFS应用

​	01-无限图G是否连通问题？调用一次DFS-VISIT,如果还有结点是WHITE,则不连通	; O(|V|+|E|)
​	02-寻找无向图连通分支？每执行一次DSF-VISIT得到1个连通分支；可以再增加数组为每个结点做标记；在num++处，满足black 且 标记为0，为一个连通；收集并标记为1 ; O(|V|+|E|)
​	03-无向图G是否是1棵树？注意是树，不包括森林；那么看由美亚反向边-成环则不是； 看是不是森林-连通吗； O(|v|)

```c
//深度优先搜索;有向图-邻接表(可能存在前向边-画出图好理解； 交叉边)
	DFS-VISIT(G,s) // G-有向图、s为根 ;从给定根做一次DFS搜索-相当于树的情况
		time+=1;  // *！进来之前，结点一定是white
		s.color = grey;
		s.st = time;
		
		for all v = adj[s]
			if(v.color == white)
				v.p = s
				BFS(G,v)
			if(v.color == grey) //无向图只有反向边(指向祖先结点) 和 树边 ； 无前向边（祖先指向后代-非树边）
				print"有环"
		v.color = black;
		time+=1;// *！每次遍历完一个结点的全部邻接结点，回溯时间要+1；从结构看，因为是DFS，越深的结点是先遍历完的
		v.ft = time; 
	
	//成不成环问题，与无向图的处理方法是一样的
```



### DFS解强连通图问题

求有多少个强连通图（连通性问题）-不能按照无向图的方法了
	强连通图问题：
		**01-做一遍DFS(G)算法；**
		**02-将G转置得GT(V,ET)**
		**根据02，根据|V|中结点v.ft的顺序**
		**在GT(V,ET)中执行 DFS-VISIT算法；每次挑还是白色的结点；**
		**每次DFS-VISIT得到的就是有向图的1个连通图**



### DFS-拓扑排序

```c
//其它应用
	拓扑排序-利用DFS做：
		0a-当一个结点DFS访问结束，添加到链表中，最后返回链表
		0b-对结点按访问结束时间从大到小输出，就是1个拓扑排序
		O(|V|+|E|)
		
```

### BFS算法

广度优先搜索BFS
基本思想：先找距离源点距离为k的结点，再找距离(k+1)的结点

```c
BFS(G) // 以为s为根
			for all v belong |V|
				v.color = white
				v.p = null;
				v.d = ∞;
			
			for(all v belong |V|)
				if v.color = white
					v.d = 0
					BFS-VISIT(G,v)
		
```

```c
			
	BFS-VISIT(G,r) // 以r为根 ; 求s-t距离；直接调用BFS-VISIT(G,s) //然后再对代码做小小修改
			r.color = grey
			Q.ENQUEUE(r)
			
			while Q.isEMPTY==false
				u=Q.DEQUEUE
				visist"u"
				for all v belong to G.adj[u]
					if(v.color == white)
						v.d=u.d+1;
						v.p=u
						v.color = grey
						Q.ENQUEUE(v)
				
				u.color = black
			
			return G
```

通过BFS可以得到：
		从某点出发到其它结点的最短路径
		以s为根的BFS树（前提是不成环、连通，求一个连通子图，有结点被指定为根）
		邻接表存储图，BFS算法时间复杂度为 O(|V|+|E|); 若是邻接矩阵，则为O(|V|^2)

### 最小生成树算法（Kruskal和 Prime）

**思想**

每次从未选边集选不成环的边；(算法结束，是否包括所有点，是则成功)一般对象是连通的（无向图）

01-初始化：每个结点为1个连通分支
02-对于两个连通分支，选择他们的权值最小的边，合并这两个连通分支，重复这一过程
		利用并查集：MAKE-SET(v) 、FIND-SET(v) 、UNION(u,v) 
		输入：加权连通图
		输出ET

```c
MST-KRUSAL(G,w) //w保存了边的权重信息
			for v belong to all G.V
				MAKE-SET(v)
				
			sort the G.E in increasing order using input w 
			
			for each (u,v) belong to G.E
				if FIND-SET(u)!=FIND-SET(v)
					UNION-SET(u,v)  //最高时间复杂度可以达到 O(|lgV|)
					A=A∪{(u,v)} // A保存边集
			
			return A
			
		//时间复杂度：O(|E|lg|V|)
```

**相关算法：并查集**

```c
并查集由一个个不相交（领主不同）的集合构成S={S1,S2,...,Sk}
		具有3个操作
			MAKE-SET(x): Si={x}，S=S∪{x}  //O(1)
			FIND-SET(x)	//O(1)
			UNION(x,y)  //O(n)
		//基于并查集求无向图中所有连通分支-对比DFS方法\BFS方法
		CONNECTED-COMPONENTS(G)
			for each v belong to G.V
				MAKE-SET(v)
			for each edge (u,v) belong to G.E
				if(FIND-SET(u)==FIND-SET(v))
					UNION(u,v)
			count how many SET in S //统计S中有多少个集合就可知有多少个连通图
			
		//实现并查集的数据结构设计，可以用链表实现；
```



### Prime算法

**思想：**

01-创建一颗局部树VA并不断增长
02-每次选一条权值最小的边(选边也是选点)，这条边要连接局部树和未在局部树(V-VA)中的结点

**分析:**

01-使用数据结构"优先队列-Q"来实现（上面已总结）
02-优先队列元素是结点,属于{V-VA}，记为v；局部树{VA}结点记为(u,v)
	  优先队列基于最小堆实现，每个元素(结点)的key值是v到u中所有边中权值最小那条边的权值
03-EXTRACT-MIN(Q) 表示从Q中取出当前key最小的结点

```c
PRIM(G,w,r) //w 保存了每条边的权值
			Q=空集合 // Q用来表示一个最小优先队列
			for each v belong G.V
				v.p = null //指向结点在生成树中的父结点- 用来保存"MST"结构信息的
				v.key = ∞
				Q.insert(v)
			DECREASE-KEY(Q,r,0)	// 选择图中一个节点r,将其key置为0，则r默认为MST-TREE的根 ； 所以r 已知！
			while Q.isEMPTY ==false 
				u = EXTRACT-MIN(Q) // EXTRACT-MIN(Q): 1-取Q中key最小元素(第；2- 将u从Q删除 ； 根据上面，第一次取的是r
				for each v belong to G.Adj[u] //看需不需要修改
					if(v belong to Q && w(v,u)<v.key) //因为u已经加入了VA
						v.p = u //常规的邻接表，是没有v.p这个域的 			//Q1:有些结点的指针p不会修改，对吧？
						DECREASE-KEY(Q,v,w(u,v))
						
			
			//时间复杂度：O(|E|lg|V|)
			//Q2：仅靠当前信息，无法很好的还原MST树
```





# OJ

## 数组

### 将数组的0元素移动到最后

题目：

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:

必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。

我的解法：

````java
class Solution {
    public void moveZeroes(int[] nums) {
       
        int f,length=0;
        for(int i=0;i<nums.length;i++){

            if(nums[i]!=0 && length!=0){
                int temp = nums[i];
                nums[i] = nums[i-length];
                nums[i-length] = temp;
                f = i;
                continue;
            }

            if(nums[i]==0){
                length++;
                f =i;
                continue;
            }
        }
        
    }
}
````

更好一点的解法，即只需要考虑一直一交换与不交换就好·

````java
class Solution {
    public void moveZeroes(int[] nums) {
        int n = nums.length, left = 0, right = 0;
        while (right < n) {
            if (nums[right] != 0) {
                swap(nums, left, right);
                left++;
            }
            right++;
        }
    }

    public void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/move-zeroes/solution/yi-dong-ling-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
````



### 求股票的最佳卖出时机I-III

I-题目描述：


给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

 

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

题解一：求出最大最小值，递归划分数组

`````java
/**
时间复杂度：O(nlg(n))
空间复杂度：O(nlg(n))

*/
class Solution {
    public int maxProfit(int[] prices) {
        return calmaxProfit(prices,0,prices.length-1);

    }
    public int calmaxProfit(int[] prices,int start ,int end){
        if(start >= end) return 0; 
       
        int maxIndex =start , minIndex =end;
        for(int i=start ; i<=end ; i++){
            if(prices[i]>=prices[maxIndex]){
                maxIndex = i;
            }
            if(prices[i]<prices[minIndex]){// 注意，这一 < 是为了最小值尽可能取左边元素
                minIndex = i;
            }  
        }

        if(minIndex<maxIndex) return prices[maxIndex]-prices[minIndex];

        //分割原来数组[start,maxIndex][maxIndex,minIndex][minIndex,end]
        int tMin =Integer.MAX_VALUE;
        int profitT1 = 0;
        for(int i=start ; i<=maxIndex ;i++){
            if(prices[i] <= tMin) tMin = prices[i];
        }
        profitT1 = prices[maxIndex]-tMin;

        int profitT2 = calmaxProfit(prices,maxIndex+1 ,minIndex-1);
        
        int tMax =Integer.MIN_VALUE;
        int profitT3 = 0;
        for(int i=minIndex ; i<=end ;i++){
            if(prices[i] >= tMax) tMax = prices[i];
        }
        profitT3 = tMax-prices[minIndex];

        int maxProfit = profitT1 >= profitT2 ? (profitT1 >= profitT3 ? profitT1: profitT3) : (profitT2 >= profitT3 ? profitT2 : profitT3);
        return maxProfit;
    }
           
}
`````

题解2： **最好的解法**: 求最小值------->假设是在历史最低点买入



```` java
public class Solution {
    public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice) {
                minprice = prices[i];
            } else if (prices[i] - minprice > maxprofit) {
                maxprofit = prices[i] - minprice;
            }
        }
        return maxprofit;
    }
}


````

II-题目描述

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

`````java
/**
原问题等价于：
对于股票prices[]对应的折线图，寻找全部的单调递增子区间，在每个单调递增子区间起始点买入，最高点卖出
*/

class Solution {
    public int maxProfit(int[] prices) {
        int profit=0;
        int upStart=0;
        int upEnd = 0;
        for(int i=1 ; i<prices.length ;i++){
            if(prices[i]>=prices[i-1]){
                upEnd = i;
                if(i == prices.length -1) profit += (prices[upEnd] - prices[upStart]);
                else continue;
            }else{
                profit += (prices[upEnd] - prices[upStart]);
                upStart = i;
                upEnd = i;
            }
        }
        return profit;

    }
}
`````

`````java
//贪心的把每一段上升加起来就好 ； 更简洁
class Solution {
    public int maxProfit(int[] prices) {
        int ans = 0;
        int n = prices.length;
        for (int i = 1; i < n; ++i) {
            ans += Math.max(0, prices[i] - prices[i - 1]);
        }
        return ans;
    }


`````





## 树

### 两棵树合并

思路：

可以使用深度优先搜索合并两个二叉树。从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。

两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。

如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；

如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；

如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。

对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过

```` java
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == null) {
            return t2;
        }
        if (t2 == null) {
            return t1;
        }
        TreeNode merged = new TreeNode(t1.val + t2.val);
        merged.left = mergeTrees(t1.left, t2.left);
        merged.right = mergeTrees(t1.right, t2.right);
        return merged;
    }
}
````



### 将有序数组转换为平衡二叉搜索树

题目：给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。



分析：

1.相关性质熟悉。二叉搜索树，左小右大；平衡树的相关概念

2.二叉搜索树的中序遍历是递增的；所以 升序 的nums数组，是要构建的树的中序遍历；

3.给定一棵树的中序遍历，无法唯一确定一棵树。同样，再加上一个限制条件，平衡的二叉搜索树，同样该树是不唯一的，所以答案有多种；

4.以下面的策略，便可构造题目要求的树：从nums数组取出根结点。nums.length 是奇数，呢么根结点是确定，否则，构建的树情况有多种，取决于根结点的选择；eg.[1,3,5,7] 可以选择3为根，也可以选择5为根

5.由于数组是升序的，二叉搜索树左小右大的性质，选出根结点后，便可以递归的构造目标树。

```` java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
//我的题解：
//空间复杂度：会传建子数组，子数组个数2*log(n) ,每个长度O(n)； 所以空间复杂度O（nlog(n)）
//时间复杂度：O(n)； nums数组每个元素被取为root一次

class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        //递归终止条件
        if(nums.length == 1) {
            TreeNode leaf = new TreeNode(nums[0]);
            return leaf; 
        } 
        if(nums.length == 0)  return null;

        int rootNum = nums[nums.length/2];
        TreeNode root = new TreeNode(rootNum);
        int[] lNums = Arrays.copyOfRange(nums,0,nums.length/2); //[start,end) , 所以不用-1
        int[] rNums = Arrays.copyOfRange(nums,nums.length/2+1,nums.length); 
        root.left = sortedArrayToBST(lNums);
        root.right = sortedArrayToBST(rNums);

        return root;

    }
}
//参考题解
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return helper(nums, 0, nums.length - 1);
    }

    public TreeNode helper(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }

        // 总是选择中间位置左边的数字作为根节点
        int mid = (left + right) / 2;

        TreeNode root = new TreeNode(nums[mid]);
        root.left = helper(nums, left, mid - 1);
        root.right = helper(nums, mid + 1, right);
        return root;
    }
}

//时间复杂度：O(n)，其中 n 是数组的长度。每个数字只访问一次。

//空间复杂度：O(\log n)，其中 n是数组的长度。空间复杂度不考虑返回值，因此空间复杂度主要取决于递归栈的深度，递归栈的深度是 //O(\log n)。

````



### *对称二叉树判定

题目描述：给两棵树，判断它们是不是镜像对称的。

解题思路：

**1-错误思路**：通过LNR和RNL遍历，判断遍历序列是不是相同。存在某种树，LNR和RNL结果一样，但部署镜象树

$eg：[1,2,2,2,null,2]$

2-递归解法：用两个指针指向两颗树，镜像移动，判断指针所指结点是否有相同的值。

````java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root,root);
    }

    public boolean check(TreeNode p1 , TreeNode p2){
        if(p1 == null && p2 == null) return true;

        if(p1 == null || p2 == null) return false;

        return p1.val == p2.val && check(p1.left,p2.right) && check(p1.right,p2.left);
    } 
}
````

$O(n) , O(n)$

因为遍历这棵树，树有n个结点，所以渐进时间复杂度是O(n)

空间复杂度和递归使用栈空间大小有关，这里递归层树不超过n（即使是单支树），每层只需要单位时间复杂度，故总空间复杂度是O(n)

3-非递归解法-迭代解法

我们用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？

**基于层次遍历算法实现。对于镜象树，如果是用层次遍历，层次遍历时从左到右，或者从右到左的应该是一样的。**

**利用这一点，对同一棵树，同时进行从左到右，从右到左的层次遍历，保存在 一个队列中，这样每次出队的两个元素，应该相同的。**

// 不能用不同时的方法。比如先从左到右参差遍历，保存遍历结点序列，再从右到左来一遍。这样会陷入错误解法1中的问题。解法3本质是和递归解法一样的，通过同时镜像遍历达到准确校验目的

初试时，根结点入队两次。

首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。

````java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
 //用中序遍历的两种形式 LNR 和 RNL ，对称则结果是一样的
 //难点：递归过程如何保存，用什么数据结构？
 //用数组保存显然不如ARRAY LIST 方便；只需要一直add 就可以了
class Solution {
    public boolean isSymmetric(TreeNode root){

        return check(root , root);

    }
    public boolean check(TreeNode l , TreeNode r){
        Queue<TreeNode> q = new LinkedList<TreeNode>();
        q.offer(l);
        q.offer(r);
              
        while(!q.isEmpty()){
            l = q.poll();
            r = q.poll();

            if(l==null && r==null) continue;
            if(l==null || r==null || l.val != r.val) return false;
           
            q.offer(l.left);
            q.offer(r.right);

            q.offer(l.right);
            q.offer(r.left);
        }  
        return true;   

    }
    
}
````



## *二叉树直径

题目描述：

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

 

示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

基本思路：求每个结点的直径，取其中最大值。每个结点直径 = 左子树深度+右子树深度

````java
public class solution7 {
    private List<Integer> diameterOfNodeList = new ArrayList<>();

    public int diameterOfBinaryTree(TreeNode root) {
        traverseOfTree(root);
        int maxDia = Integer.MIN_VALUE;
        for (int i = 0; i < diameterOfNodeList.size(); i++) {
            if (diameterOfNodeList.get(i) >= maxDia) maxDia = diameterOfNodeList.get(i);
        }
        return maxDia;
    }

    public int traverseOfTree(TreeNode root) {
        if (root == null) return 0;

        int rDepth = 0;
        int lDepth = 0;

        if (root.left != null) {
            rDepth = traverseOfTree(root.left) + 1;
        }
        if (root.right != null) {
            lDepth = traverseOfTree(root.right) + 1;
        }
        diameterOfNodeList.add(rDepth + lDepth );
        return rDepth >= lDepth ? rDepth : lDepth;
    }
}
````

代码简化

```java
class Solution {
    int ans;
    public int diameterOfBinaryTree(TreeNode root) {
        ans = 1;
        depth(root);
        return ans - 1;
    }
    public int depth(TreeNode node) {
        if (node == null) {
            return 0; // 访问到空节点了，返回0
        }
        int L = depth(node.left); // 左儿子为根的子树的深度
        int R = depth(node.right); // 右儿子为根的子树的深度
        ans = Math.max(ans, L+R+1); // 计算d_node即L+R+1 并更新ans
        return Math.max(L, R) + 1; // 返回该节点为根的子树的深度
    }
}

```



****



## 链表

### 反转链表

边界条件的处理



### 合并两个升序链表

**方法一： 暴力合并**

无言。- 。 - 

```` java

class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode preHead = new ListNode(-1);
        ListNode pre = preHead;

        while(l1 != null && l2 != null){
            if(l1.val <= l2.val){
                pre.next = l1;
                pre = l1;
                l1 = l1.next;
            }else{
                pre.next =l2;
                pre = l2 ;
                l2 = l2.next;
            }
        }
        pre.next = l1==null ? l2:l1;
        return preHead.next;
    }
}
````

**方法二: 递归合并**

````java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 ==null && l2 ==null) return null;
        if(l1 == null && l2 !=null ) return l2;
        if(l1 != null && l2 == null) return l1;
        
        if(l1.val<=l2.val){
            l1.next = mergeTwoLists(l1.next,l2);
        }else{
            l2.next = mergeTwoLists(l1,l2.next);
        }
        
        return l1.val<=l2.val ? l1 : l2 ;

      
    }
}
````



### 寻找交叉链表的公共结点

题目描述：编写一个程序，找到两个单链表相交的起始节点。

````` java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
 
public class Solution{

    public ListNode getIntersectionNode(ListNode headA,ListNode headB){
        if(headA == null || headB == null) return null;

        ListNode scan1 = headA;
        ListNode scan2 = headB;
        int l1=0,l2=0;
        while(scan1 != null){
            l1++;
            scan1 = scan1.next;
        }
        while(scan2 != null){
            l2++;
            scan2 = scan2.next;
        }
        int distance = l1>=l2?(l1-l2):(l2-l1);
        //重置扫描指针
        scan1 = headA;
        scan2 = headB;

        //长度长的链表的扫描指针，先走distance距离
        if(l1>=l2){
            while(distance > 0){
                scan1 = scan1.next;
                distance--;
            }
        }else{
            while(distance > 0 ){
                scan2 = scan2.next;
                distance--;
            }
        }
        while(!scan1.equals(scan2) ){ //避免空指针调用方法的异常 
            scan1 = scan1.next;
            scan2 = scan2.next;
            if(scan2 == null || scan1 == null) break; //避免空指针；正常情况，如果找不到，scan1 和 scan2是同时为null的
        }
        
        return scan1 == null? null : scan1;  
    }   
}


`````

$O(1),O(1)$

<img src="mdPics/image-20210419221839374.png" alt="image-20210419221839374" style="zoom:50%;" />



### *判定链表是否有环

题目描述：给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 

<img src="mdPics/image-20210428095956964.png" alt="image-20210428095956964" style="zoom:50%;" />



解法一：使用哈希表；使用哈希表，将**ListNode**作为key

````java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
 //题目中的pos没有实际意味，只是为了解释这个题目
 
public class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> seen = new HashSet<ListNode>();
        while(head!=null){
            if(!seen.add(head)){
                return true;
            }
            head = head.next;
        }
        return false;
    }
}
````



解法二：快慢指针：

理解该算法理解的（包括时间复杂度分析）一个关键点：

因为指针有快慢，所以进入圈后，快追上慢最多只需要多走N个结点（头尾成环），时间复杂度是$O(n)$

**边界判定**：

本题的边界很有意思。在链表中移动指针一定要注意先注意空指针异常的判定。仔细体会

````java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
 //题目中的pos没有实际意味，只是为了解释这个题目
 
public class Solution {
    public boolean hasCycle(ListNode head) {

        if(head == null || head.next == null) return false;
        //要先上面判定，下面才能赋值

        ListNode slow = head;
        ListNode fast = head.next;
        
        //一样的道理，指针移动前要避免空指针异常
        while(fast != slow ){
            //成环，不能有后继Null
            if(fast == null || fast.next == null) return false; // fast 走得快，只要判断fast就

            slow = slow.next;
            fast = fast.next.next;  //新的fast可能是个null
        }

        return true;
        
    }
}
````



### 回文链的判定

题目描述：

请判断一个链表是否为回文链表。

示例 1:

输入: 1->2
输出: false
示例 2:

输入: 1->2->2->1
输出: true
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

1-用递归解

- 基本思路，利用递归的性质，先递归到最后结点然后开始比较
- 要实现这个算法，需要一个从前到后的“全局指针”，递归到最后一个结点后，开始比较。很简单，定义一个类字段就好了。
- 那么剩下的难点就在于，如何构造递归代码了；递归，其实是符合人的思维逻辑的
- $O(n),O(n)$

````java
private ListNode frontPoint = new ListNode();//递归之外的一个指针，作为类的字段来出现（类似-全局变量，对类而言）

    public boolean recursivelyCheck(ListNode currentNode){
        if(currentNode != null){
            if(!recursivelyCheck(currentNode.next)){ //首先要递归到最后，才能开始判断
                return false;
            }
            //不在往下递归，既本层，本结点的判定，与frontPoint所指的Node应该一样
            if(currentNode.val != frontPoint.val){
                return false;
            }
            frontPoint = frontPoint.next;

        }
        return true;
    }

    public boolean isPalindrome(ListNode head){
        frontPoint = head;
        return recursivelyCheck(head);
    }
````



解法2- 非递归解

- 基本思路:逆转后半部分-》比较-》恢复原链表。缺点是，这样的算法不适合并发程序。
- 先找到后半部分的头节点，我们定义前半部分长度》=后半部分。这样设计一个求前半部分最后一个的函数，更便捷。（恢复链表时）
- 使用到了原地反转单链表

````java
 public boolean isPalindrome(ListNode head){
        ListNode firstHalfNode = endOfFirstHalf(head);
        ListNode reverseSecondHalfHead = reverseList(firstHalfNode.next);


        //开始比较
        ListNode p1 = head;
        ListNode p2 = reverseSecondHalfHead;

        while(p2!=null){ //该算法后面半部分的链表总是比较短的
            if(p2.val != p1.val){
                return false;
            }
            p2 = p2.next;
            p1 = p1.next;
        }
        //恢复原来的链表
        firstHalfNode.next=reverseList(reverseSecondHalfHead);
        return true;

    }

    //通过快慢指针，可以确定后半部分的链表。不管是偶数长度还是奇数长度，我们都可以找到 后半部分的链表的头节点
    public ListNode endOfFirstHalf(ListNode head){
        ListNode fast = head;
        ListNode slow = head;

        while(fast.next!=null && fast.next.next!=null){ //链表-移动前先判空
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow ;
    }

    public ListNode reverseList(ListNode head){

        ListNode pre = null;
        ListNode currentNode = head;
        while(currentNode!=null){
            ListNode next = currentNode.next;
            currentNode.next = pre;
            pre = currentNode;
            currentNode = next;

        }
        return pre;
    }

````



## 字符串

### 求最长无重复字串的长度

题目描述

```` md
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
````

思路

```` java
* 求每个字符开头的最长不重复字串的长度，记录最大值
* 高效的方式是滑动窗口。有两个指针，均不回溯
* 判断当前窗口内有无重复字符，采用 HashSet 作为数据结构
````

````java
class Solution {
    public int lengthOfLongestSubstring(String s){
        int start =0 , end=0, len=0,res=0;
        Set<Character> window = new HashSet<>();
        while(start<s.length()&&end<s.length()){
            if(window.contains(s.charAt(end))){
                window.remove(s.charAt(start));//逐个移动start
                start+=1;
            }else{
                window.add(s.charAt(end));
                len = end-start+1;
                if(len > res) res = len;
                end+=1;
            }
        }
        return res;
    }
}
````

$O(s.length)$

$O(字符集大小)：HashSet 的可能最大值$

## 求最长回文字串

题目描述

`````
给你一个字符串 s，找到 s 中最长的回文子串。
示例 1：

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
示例 2：

输入：s = "cbbd"
输出："bb"

`````

**我的解**-思路及注意事项

- 可以对全部回文串分成两类：一类字符个数有奇数个，对称轴是某个元素；一类字符个数偶数个，对称轴是两元素之间
- 遍历一遍字符串，求以每个元素为“中心”（该元素是对称轴，或者对称轴在其后面）时两种情况的最长字串，记录最大值
- 遍历结束，得到答案

复杂度

- 时间：理论上是$O(n) - O(n^2)$，可以做优化 
- 空间：$O(1)$
- ![image-20210511152436565](mdPics/image-20210511152436565.png)

代码

````java
class Solution {
    public String longestPalindrome(String s) {
        String ans = "";
        int len=0,j=0;
        
        for(int i=0; i<s.length();i++){
            len=0;
            j=0;
            //以s.charAt(i)为对称轴
            while(i-j>=0 && i+j<s.length() &&s.charAt(i-j)==s.charAt(i+j) ){
                    len = 2*j+1;
                    if(len>ans.length()){
                        ans = s.substring(i-j,i+j+1);
                    }
                    j = j+1;
            }
            //对称轴在s.charAt(i)后面
            len=0;
            j=1;
            while(i-j+1>=0&&i-j+1<=i && i+j<s.length()&&s.charAt(i-j+1)==s.charAt(i+j)){
                len = 2*j;
                if(len>ans.length()){
                        ans = s.substring(i-j+1,i+j+1);
                    }
                j = j+1;
            }
        }
       
    return ans;
    }
}
````

**动态规划解法**

- 动态规划思路：利用动态规划的思想，每一个回文串都是由更短的回文串组成的。（原问题可以通过一步操作，变成规模更小的子问题来解决）。
- 符号和数学定义：
  - s[i,j] 表示s的一个字串，从i开始，j结束
  - $P(i,j)表示s[i,j]是否是回文串，P(i,j)={true,false)$
- 转移方程：$P(i,j)=P(i+1,j-1)^(S_i == S_j)$
- 边界条件：$P(i,i)=true ; P(i,i+1)=(S_i == S_{i+1})$
- 注意：动态规划本质是查表法，程序执行过程不断填表，既从短串到长串的过程；

````java

public class SoHuiWengCuan {
        public String longestPalindrome(String s) {
            int strlen = s.length();
            if (strlen < 2) {
                return s;
            }

            int maxLen = 1;
            int begin = 0;
            // dp[i][j] 表示 s[i..j] 是否是回文串
            boolean[][] dp = new boolean[strlen][strlen];
            // 初始化：所有长度为 1 的子串都是回文串
            for (int i = 0; i < strlen; i++) {
                dp[i][i] = true;
            }

            char[] charArray = s.toCharArray();
            // 递推开始
            // 先枚举子串长度
            for (int subL = 2; subL <= strlen; subL++) {
                // 枚举左边界，左边界的上限设置可以宽松一些
                for (int i = 0; i < strlen; i++) {
                    // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                    int j = subL + i - 1;
                    // 如果右边界越界，就可以退出当前循环
                    if (j >= strlen) {
                        break;
                    }

                    if (charArray[i] != charArray[j]) {
                        dp[i][j] = false;
                    } else {
                        if (j - i < 3) { // 边界情况：既 aba，aa，a 情况；
                            dp[i][j] = true;
                        } else {
                            dp[i][j] = dp[i + 1][j - 1];
                        }
                    }

                    // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                    if (dp[i][j] && j - i + 1 > maxLen) {
                        maxLen = j - i + 1;
                        begin = i;
                    }
                }
            }
            return s.substring(begin, begin + maxLen);
        }
}
````

复杂度

- 时间复杂度：$O(n^2)$;动态规划状态总数$O(n^2)$ , 求解每一个状态%$O(1)$时间

- 空间复杂度：$O(n^2)$

  

**中心扩展算法**

$public int expandAroundCenter(String s, int left, int right)$ 这个函数设计不错，统一了两种情况

`````java
class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) {
            return "";
        }
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            int len1 = expandAroundCenter(s, i, i);
            int len2 = expandAroundCenter(s, i, i + 1);
            int len = Math.max(len1, len2);
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }

    public int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            --left;
            ++right;
        }
        return right - left - 1;
    }
}

`````





## 递归

### 爬楼梯

题目描述：假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。



方法1：普通递归，速度慢

`````java
class Solution {
    public int climbStairs(int n) {
       int sum = climb(n);
        return sum;
    }
    public int climb(int step){
        if(step == 2) return 2;
        if(step == 1) return 1;
        return (climb(step-1)+climb(step-2));
    }
}
`````

方法2：带路径保存的递归

速度的提升在于： 避免了重复子问题的求解

````java
class Solution {
    public int climbStairs(int n) {
       int [] ans = new int[n+1]; 
    
       int sum = climb(n,ans);
       return sum;
    }
    public int climb(int step,int[] ans){
        if(ans[step]!=0) return ans[step];

        if(step == 2) return 2;
        if(step == 1) return 1;
        ans[step]=climb(step-1,ans)+climb(step-2,ans);

        return ans[step];
    }
}
````

方法3：循环-自底向上求解

````java
class Solution {
    public int climbStairs(int n) {
       int [] ans = new int[n+1]; 
       
       for(int i=1; i<=n;i++ ){
           if(i ==1 ) ans[i] =1;
           if(i ==2 ) ans[i] =2;
           if(ans[i]==0){
               ans[i] = ans[i-1]+ans[i-2];
           } 
       }
       return ans[n];   
    }
}
````





## 动态规划

### 最大子序列和

题目描述:

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：

输入：nums = [1]
输出：1

1-动态规划解：

用$f(i)$表示 **以num[i]结尾** 的最长序列和

**动态规划方程** $f(i)=max{f(i-1)+nums[i],nums[i]}$

````java
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0, maxAns = nums[0];
        for (int x : nums) {
            pre = Math.max(pre + x, x);
            maxAns = Math.max(maxAns, pre);
        }
        return maxAns;
    }
}

````



2-我的解法 $O(n^2),O(n)$

`````java
class Solution {
    public int maxSubArray(int[] nums) {
        int [] sumArr = new int[nums.length+1];
        sumArr[0] = 0;
        for(int i=1;i<sumArr.length;i++){
            
            sumArr[i] = sumArr[i-1]+nums[i-1];
        }
        int maxSum= Integer.MIN_VALUE;
        for(int i=0;i<sumArr.length;i++){
            for(int j=i+1;j<sumArr.length;j++){
                if(sumArr[j]-sumArr[i] > maxSum) maxSum = sumArr[j] - sumArr[i];
            }
        }
        return maxSum ;

    }
}
`````

3-递归线段树解法，可以求解任意区间，且保存起来。只需要$O(log n)$的时间复杂度可以查询修改





## 技巧题

### 寻找数组中只出现一次的数

题目描述：一个数组中 $2m+1$ 个数，m=0，1，2，... ；m个数各出现两次，有一个数只出现1次，求这个数；要求$O(1),O(1)$

**技巧：利用异或计算的性质**

$ a \oplus 0 =a$

$a \oplus a =0$ 

**异或运算有交换律和结合律**



### 多数元素

题目描述：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素

题解算法：

````java
//投票算法
class Solution {
    public int majorityElement(int[] nums) {
        int candidate = nums[0];
        int count=0;
        for(int i=0;i<nums.length;i++){
            if(count == 0){
                candidate =nums[i];
                count++;
            }else{
                if(candidate == nums[i]){
                    count++;
                }else{
                    count--;
                }
            }
        }
        return candidate;

    }
}
//算法正确性证明：https://leetcode-cn.com/problems/majority-element/
//O(1),O(1)
````



### 寻找数组中消失的数

题目描述：给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, n] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

示例:

输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]

分析题目：

有限制条件，数组的元素取值为[1,n]，而数组大小为n ；有些元素出现0，1，2 次（实际上此题可扩展为出现任意次）；注意，如果限制条件是出现 {1，2}次, 则可以用异或性质了.

最简单的，我们可以用一个哈希表来记录范围在[1，n]之间的元素是否出现，需要的哈希表长度是n。 这里我们发现，数组长度也是n，那么最好使用数组来充当哈希表。通过一些方法，在便利的过程中，对出现的元素进行标记。

解题思路一：

假设 **元素是** nums[i] 应该映射到 **下标是** nums[i] -1  的位置上；

标记方法：对遍历过程出现元素，对其映射位置的当前值加上数字n ，说明元素出现过至少一次，加n可以方便还原。 注意 ，这里"**哈希结构**"中的key 是 数组下标

```` java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int n = nums.length;
        int x;//元素应该映射到的哈希表的 key 
        
        for(int i =0 ;i<nums.length;i++){
            x = (nums[i]-1)%n; //x 是数nums[i] 该去的位置，逻辑上这里求余实际是没必要的，但不求余通过不了编译
            nums[x] = nums[x]+n ;//+n 的目的，为了标记该数出现，也方便还原数组
        }

        List<Integer> vanishNum = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            if(nums[i]<=n) vanishNum.add(i+1);
            else nums[i] %= n; //还原nums[]
        }
        return vanishNum;

    }
}
````



解题思路二：

与一 大体一致，只是标记方法不同。

对于key: x = (nums[i]-1)%n 

将$nums[x]* (-1)$ 表示已经出现过

```` java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int n = nums.length;
        int x;//元素应该映射到的哈希表的 key 
        
        for(int i =0 ;i<nums.length;i++){
            x = (Math.abs(nums[i])-1)%n; 
            if(nums[x]>=0)  nums[x] = nums[x]*(-1) ;
           
        }

        List<Integer> vanishNum = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            if(nums[i] >=0 ) vanishNum.add(i+1);
            else nums[i] *= (-1); //还原nums[]
        }
        return vanishNum;

    }
}
````

**总结**

一与二的本质是相同的 , 利用原来数组充当哈希表，只是标记方式的不同











#  JAVA细节

```` java
  String.charAt(index)//
````



