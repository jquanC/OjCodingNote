## 分治法

### 1-最大子数组(和)问题

**问题描述**

​		给定一个数组，**求其最大连续子数组的和**

**策略**

​		分治法解,将原问题转化为：比较左子数组的最大子数组、右子数组的最大子数组、跨中间 位置的最大子数组中的最大者，就是原问题的解。通过这样的转化，原问题可以不断划分为小问题。

​		关键是求和理解跨中间最大子数组。跨中间最大子数组并非原问题的最大子数组。它必须要跨中间元素，求解该子问题只需要 **O(n)**的时间复杂度。

**实现**

```c++
//伪代码
//求跨中间元素的最大子数组
FIND-MAX-CROSSING-SUBARRAY(low,high,mid,A) 
	lest-sum = ∞
	sum=0
	for i=mid down to low
		sum+=A[i]
		if sum>left-sum
			left-sum = sum
			max-left=i
	lest-sum = ∞
	sum=0
	for j=mod up to high
		sum+=A[i]
		if sum>right-sum
			right-sum=sum
			max-right=j
	return(max-left,max-right,left-sum+right-sum)
            
//递归求解问题
	
FIND-MAX-SUBARRAY(low,high,A)
	//递归截止条件
	if(low == high) return(low,high,A[low])
		
	mid= Dint((low+high)/2)
	(left-low,left-high,left-sum)=FIND-MAX-SUBARRAY(low,mid,A)
	(right-low,right-high,right-sum)=FIND-MAX-SUBARRY(mid,right,A)
	(cross-low,cross-right,cross-sum)=FIND-MAX-CROSSIN-SUBARRY(low,high,A)
	
	if(left-sum>=cross-sum&&left-sum>=riht-sum) return(left-low,left-high,left-sum)
	if(right-sum>=cross-sum&&riht-sum>=left-sum) return(right-low,riht-high,right-sum)
	if(cross-sum>=left-sum&&cross-sum>=riht-sum) return(cross-low,cross-high,cross-sum)

```

### 2-两个有序数组的中位数问题

**问题描述**		

​		给定两个大小为 m 和 n 的**有序**数组 A 和 B 。逻辑上归并后的数组为C。请找出C的中位数。要求算法的时间复杂度为 O(log (m+n))



**分析** 

​		要实现这个时间复杂度，用分治法；用最后一步归并方法也可以求解，但时间复杂度是 **O(m+n)**。

​		**一开始的问题：找中位数就是找(归并后)第k个数，k定义如下：**
​		**(len(A)+len(B))为偶**：令k1=(len(A)+len(B))/2 和k2=(len(A)+len(B))/2 +1 个; (C[k]+C[k+1])/2 （#C[k1]+C[k2])/2？）#就是中位数;中位数不一定就要是原来存在的元素，比如元素个数是偶数的时候通过这样求得。
​		**(len(A)+len(B))为奇：**令k=(len(A)+len(B))/2 + 1，C[k]既是
​	

但是,这是两个有序数组，**有更好的解法：**
	还是定义k=(len(A)+len(B))/2
		令 p=k/2-1,q=k/2(=k-p-1), p+q=k-1;//我们要找第k个数，通过数组特征分解第k-1个数来分解问题
		对于A[p]、B[q]的较小者，其所在序列的前面部分，肯定不包含目标值(另个不确定哦-这是理解的关键。另一个数组的前面任意一个数，都有可能是要求的数。考虑一个数组元素完全大于另外一个数组的情况)
		可以抛弃得到子序列！问题规模缩小了！
		我们先看A[p] B[q]这两个数的大小,可以获得如下信息
		if A[p] = B[q] , return A[p] 或者B[q]
		if A[p] < B[q] , 在A[p+1,len(A)] 和 B[0,len(B)]中搜索第k-p个数
		if A[p] > B[q] , 在A[0,len(A)] 和 B[q+1,len(B)]中搜索第k-q个数



**实现**

```C
//代码实现
		Find-Middle-Element(A,B)
			k=(len(A)+len(B))/2
			if((len(A)+len(B))%2==0)
				return (Find-NoK(A,B,0,len(A)-1,0,len(B)-1,k)+Find-NoK(A,B,0,len(A)-1,0,len(B)-1,k+1))/2
			else return Find-NoK(A,B,0,len(A)-1,0,len(B)-1,k+1)
		
		Find-Nok(A,B,Astart,Aend,Bstart,Bend,k)
			
			if((Aend-Astart)>(Bend-Bstart))
				return Find-Nok(B,A,Bstart,Bend,Astart,Aend,k)//保证len1始终最短-简化下面讨论代码
			if((Astart-Aend)==0) return B[k]
			
			if(k==1) return min(A[start],B[start]) //边界之一；
			p = min(k/2,Aend-Asatrt) //最短的是A数组了，前面简化作用体现出来了
			q=k-q
			if(A[Astatrt+p-1]<B[Bstatrt+q-1]) return(A,B,Astart+p,Aend,Bsatrt,Bend,k-p)
			if(A[Astatrt+p-1]>B[Bstatrt+q-1]) return(A,B,Astart,Aend,Bsatrt+q,Bend,k-q)	
			if(()==()) return A[Astatr+p-1] //想等，这两个一个是k-1,一个是 k，就是我们要找的，直接返回
```



## 堆和堆排序

**基本堆操作**

堆相关的3个操作；注意建堆的渐进紧确界是 **O(n)**

```c
//堆化过程
//以A[i]为根，1次自上而下堆化过程
	MAX-HEAPIFY(A,i,n)
		l=LEFT(i)
		r=RIGHT(i)
		if(l>n) return ;
		if(r>n) return ;
		if(A[l]<=A[r]&&A[r]>A[i]) 
			swap(A[i],A[r])
			MAX-HEAPIFY(A,r,n)
		if(A[r]<=A[l]&&A[l]>A[i]) 
			swap(A[i],A[l])
			MAX-HEAPIFY(A,l,n)
			
	//课本版本
	MAX-HEAPIFY(A,i,n)
		l=LEFT(i)
		r=RIGHT(i)
		if(l<=n&&A[l]>A[i])
			largest = l
		else larest = i
		if(r<=n&&A[r]>A[largest])
			largest = r
		if largest!=i
			swap(A[i],A[largest])
			MAX-HEAPIFY(A,largest,n)
	//建堆
	BUILD-MAX-HEAP(A,n)
		for i= Dint(n/2) down to 1
			MAX-HEAPIFY(A,i,n)
	
	//堆排序	
	HEAPSORT(A,n) //递归版本
	if n>=1
		BUILD-MAX-HEAP(A,n)
		swap(A[0],A[n])
		HEAPIFY-SORT(A,n-1)
		
	HEAPSORT(A,n) //非递归版本
		BUILD-MAX-HEAP(A,n)
		for i=n downto 1
		swap(A[0],A[i])
		MAX-HEAPIFY(A,0,i-1)
```



### 基于堆排序的最大优先队列

**基于数据结构的操作描述**

​		用最大堆实现一个最大优先队列
​		最大优先队列，队列每个元素有一个权重key;

​		INSERT(S,x):把元素x插入集合S中
​		MAXIMUM(S):返回S中具有最大关键字的元素
​		EXTRACT-MAX(S)：去掉并返回S中具有最大关键字的元素
​		INCERASE-KEY(S,x,k):将元素x的关键字增加到k;k需要比原来key大

​		显然，最大最小堆是根据key大小来建立的

**实现**

```c

	HEAP-EXTRACT-MAX(A,n) //返回key最大的元素，同时删除该元素
	if n<0
		error
	swap(A[0],A[n])
	MAX-HEAPFY(A,n-1)//交换后记得重新堆化
	return A[n]
	
	
	HEAP-INCREASE-KEY(A,i,key)//怎加
		if key<A[i]
			error
		else A[i].key = key
	
		while i>=1 && parent(i).key < A[i].key
			swap(parent(i),A[i])
			i = parent(i)
			
	MAX-HEAP-INSERT(A,key,n) //!*
		n=n+1
		A[n]=-∞
		HEAP-INCREASE-KEY(A,n,key)
		
```



## 回溯法

### 01 八皇后问题

**问题描述**

​		略

**实现**

```c
//先放(所有放法)，再判断能否放；这样逻辑比较清晰
	bool QUEEN::PLACE(int k) // k：第k行
		for(int j=0;j<k-1)
			if(x[j]!=x[k] && abs(x[k]-x[j])!=abs(k-j))
				return true
		
	
	bool QUEEN::BACKTRACE(int t)
		if(t>=n-1) sum++
		for(int i=1;i<=n;i++)
			x[t]=i;
			if(PLACE(t))
				BACKTRACE(t+1)
```



### 02 (目标)子集和问题

**问题描述**

​		给定集合，是否存在其子集，其和为S

**问题分析**

​		每个数有两种状态，故搜索树的结构是二叉树，简单回溯时间复杂度 **$O(2^n)$**

​		如果先求SUM数组，两个for循环可以穷举所有可能，时间复杂度：$O(n^2)$

​		**采用分支限界法**

​		可以选择吗：加这个数是否超过s？超过的情况截枝

​		可以选择，要选择吗？不选择，后续的数全部加起来小于s，这个情况截枝；



### 03装载问题

**问题描述**

​		轮船载货，尽量装载

**分析**

​		类似的？一个问题能不能放，能放是放还是不放，是连个独立思考的问题。-通过界限函数B(x)来判定

**实现**

```c
//r-剩下的装载能力、cw-当前装了多少、x[i]={0,1}第i个物品装还是不装、bestw-当前最优解
	void BACKTRACK(int i)
	{
		if(i>n) // 到达叶
			if cw>bestw  bestw=cw ; bestx[]=x[]//bestw和bestx[]作为全局使用
			return ; 
		
		//更新bestx、bestw、return;
		r-=w[i]；
		if(cw+w[i]<=c){ //放，看是否符合能放的条件，同时也是继续往下搜索的条件
			x[i]=1
			cw+=w[i]
			backtrack(i+1）
			cw-w[i];
			
		}
		if(cw+r>bestw){//不放，需要考虑要不要继续下搜；r在前面已经先减去该物件了
			x[i]=0;
			backtrack(i+1);//搜索右子树
		}
	r+=w[i]
	
	}	
```



### 04 批处理作业调度问题-回溯法

**问题**

​		<img src="%E7%AE%97%E6%B3%95.assets/image-20210113220915343.png" alt="image-20210113220915343" style="zoom:67%;" />

​		作业需先由1执行，然后才能由2执行；求最快的作业完成时间

**分析**		

​		**回溯搜索的空间树是一颗排列树**；确定了作业完成的次序-时间也就可以计算；
​		时间怎么计算？总时间就是，每个作业在机器2上完成时间的累加；次序已经被决定
​		需要判定的是：被执行作业在机器2上的完成时间=max(上一个作业在机器2的完成时间，该作业在机器1的完成时间)+该作业在机器2执行所需时间

​		活动选择的动态规划方程
​		**c[i,j]=max{c[i,k]+c[k,j]+1}？** 
​		对于活动选择问题，贪心可以得到最优-选择活动越早结束的活动
​		假定先对所有活动按照活动结束时间的早晚排好序
​		if cf>bestf ，即用时已经超过最优时间，则剪枝-不用递归到下一层了；不管是递归到下一层，还是直接到该层的下一种情况，都需要回溯
​		算法用来穷举排列组合的可能情况的方法比较巧妙，x[]是动态维护的：
​		初始：x[]={1,2,3}; 
​		for:用来穷举该层可选的排列
​		x[t]-当前层的选择，x[t]前面的是确定的；swap(x[t],x[j])-存在自己和自己交换的情况，比如一开始就是swap(x[1],x[1])，这也是刚开始看代码容易混淆x[]的功能的情况
​		

**实现**

```c
//变量和数据结构
//m[j][i] 作业j在机器i上的执行时间
//x[] 当前作业的调度顺序-一种排列情况-动态维护
//f1 机器1完成处理时间 ；f2 机器2完成处理时间
//cf 累计完成时间和
//bestf 记录最优cf
//bestx[] 记录最优作业排列
	
	TRACE-Flowshop(n,m[][])
		TRACE-BACKTRACK(t,n)
			if(t>n)
				if(cf<bestcf) //需要更新
					bestcf = cf
					for i tp n
						bestx[i]=x[i]
			
			for(i=t,i<=n;i++) //探索这层所有作业可能
			{
				f1 = f1+ m[x[i]][1]
				temp = f2
				f2 = max{f1,f2}+m[x[i]][2]
				cf=f2
				if(cf < bestf)
					swap(x[t],x[i]) //可以保障 i》t
					TRACE-BACKTRACK(t+1,n)
					swap(x[t],x[i])//回溯；开始是自己和自己交换
					
				//直接回溯-cf>bestf
				f1-=m[x[i]][1]
				cf-=f2
				f2=tempf
			}		
```

​		

## 贪心问题

### 01 活动选择问题

**问题**

​		给出活动集，包括活动的起始时间和结束时间；可以根据某种贪心原则计算活动全部执行完需要多少时间。

```c
	//贪心非递归实现
	GREEDY-ACTIVITY-SELECTOR(s,f)//活动的开设时间、结束时间数组(按结束时间排好序)
		n = s.length
		A={a1}
		k=1
		for i=2 upto n
			if s[i] >= f[k]
			A=A ∪ A[i]
			k=i
		return A
		
	RECURSIVE-ACTIVITY-SELECTOR(s,f,k,n) //增加虚拟活动a0,结束时间为0；初始调用 RECURSIVE-ACTIVITY-SELECTOR(s,f,0,n)
		
		m=k+1
		while m<=n && s[m]<f[k]
			m++;
		
		if m<=n
			return a[m] ∪ RECURSIVE-ACTIVITY-SELECTOR(s,f,m,n)
		else return 
		
```

### 02 跳跃数组

**题目描述**

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

 

示例 1：

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
示例 2：

输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。

**思路**

理解题意，easy

**代码**

- DFS

`````java
private boolean res = false;
    private int[] vis;
    public boolean canJump( int[] nums){
        vis = new int[nums.length];
        dfsJump(0,nums,vis);
        return res;
    }
    private void dfsJump(int ipx ,int[]nums,int[] vis){
        vis[ipx] =1 ;
        if(ipx == nums.length-1 || nums[ipx]+ipx >= nums.length-1){
            res = true;
            return;
        }
        for(int jumpLen = nums[ipx];jumpLen>0;jumpLen--){
            if(vis[ipx+jumpLen] == 0){
                dfsJump(ipx+jumpLen,nums,vis);
            }

        }

    }
`````

- 迭代

````java
public class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        int rightmost = 0;
        for (int i = 0; i < n; ++i) {
            if (i <= rightmost) {
                rightmost = Math.max(rightmost, i + nums[i]);
                if (rightmost >= n - 1) {
                    return true;
                }
            }
        }
        return false;
    }
}
````









## 动态规划

首先，需要原问题具有最优子结构。

通过一步操作将原问题转化为通过求最优子问题可解的情况。求解原问题时我们先假设最优子问题存在。当问题足够小，可解。

动态规划是一种（逻辑上）“查表”的方法，表中存储了已知的最优子问题。

### 01 切杆问题

r[n]表示长度为k的木杆切割可得的最大收益
p[i]保持长度为i的木杆的收益。假定我刀切在 k 处：r[n]=max{p[k]+r[n-k]}

```c
//递归
	CUT-ROD-AUX(p,n) //n-待切杆的长度；p-木杆价格表
		if n==0 return 0 //* 注意这个边界是0；
		
		q=-∞//q 代表长度n的杆所能获得的最大切割收益
		
		for(int i=1;i<n；i++)
			q=max{(q,p[i]+CUR-ROD(p,n-i))}
	
		return q 
```

```c
//带备忘-记忆的递归，保存所有长度切割的最优解
	MEMORIZED-CUT-ROD(p,n)
		for i=0 upto n
			r[n]=-∞
		
	MEMORIZED-CUT-ROD-AUX(p,n,r)
		if(r[n]!=-∞) return q=r[n]
		if n==0 return q=0 
		
		for(int i=1;i<=n;i++)
			//q=max{(q,p[i]+MEMORIZED-CUT-ROD-AUX(p,n-i,r))} //不带切割路径
			if(p[i]+MEMORIZED-CUT-ROD-AUX(p,n-i,r)>=q) //修改为保存切割路径
				cutin = i;
				q=p[i]+MEMORIZED-CUT-ROD-AUX(p,n-i,r)
			
		
		p[n]=cutin; //长度为n的木杆从cutin处切割可得最优解
		r[n]=q;
		return q；
```

```c
//非递归-自底向上方法
	BOTTOM-UP-CUT-ROD(p,n)
		for(int i=1;i<=n;i++)
			q=-∞
			for(j=1;j<=i/2;j++)
				q=max(q,p[j]+r[i-j])
			r[i]=q
	return r[n]
```



### 02 **背包问题**

**问题描述**

​		关于背包问题有几个问题需要理解清楚。有助于我们得出、理解动态方程。

​		子问题是什么？是更少的物品，还是更少的容量？答案是更少的物品；设想一个小偷去商场偷东西。如过商品很少，那么对他来说，偷的方案很好做；所以我们应该力求让物品减少

​		另外，学习一个动态规划算法，要掌握表的解构，查找方法；如何打印解的求解路径。

```c
//问题定义-动态规划方程
		n物、w[i]、v[i]、c、定义c[i,j]表示前i个物品在容量为j的最优价值和
		c[i,j]=c[i-1,j] // w[i]>j ，不能放
		c[i,j]=max{ //能放
			c[i-1,j-w[i])+v[i] , //放
			c[i-1,j] //不放
		}
		v[0,j]=v[i,0]=0;
```

```c
//背包实现-递归
	0-1 BAG(w,v,n,G,c[][])
			if(n==0) return c[0][c]=0;
			if(Gq
			
			if(G<w[n])//不能放
				c[n][G]=BAG(w,v,n-1,G,c[n-1][G])
			else
				c[n][G]=max{BAG(w,v,n-1,G-w[n],c[n-1][G-w[n]])+v[n],
					BAG(w,v,n-1,G,c[n-1][G])}
	
```

```c
//背包实现-非递归	
//动规的非递归算法，就是从底向上填表的过程；
		BAG(w,v,G,c[][])
		for i=0 upto n //假设重量都是整数
			c[i][0]=0;
		for j=0 upto G
			c[j][0]=0;
		
			for(int i=0;i<=n;i++)
				for(int j=0;j<=G;j++)
					if(w[i]<j)//可以放
						c[i][j]=max(c[i-1][j-w[i]]+v[i],c[i-1][j])
					else
						c[i][j]=c[i-1][j]
```



### 03 矩阵链乘问题

**问题描述**

对同一链乘矩阵，加上扩号不改变运行结果，但计算效率却可能相差巨大。

比较难的是对矩阵链乘问题的抽象；

```c
矩阵Ai的维数是pi-1 * pi
	min[i,j]=min[i,k]+min[k+1,j]+pi-1*pk*pj // (Ai*..Ak)(...Aj)
	m[1...n,1,...n]保存代价
	s[1,...,n-1,2,...,n]记录最优值m[i,j]对应的分割点;对应需要切割的情况的取值范围
	将k记录在s[i][j]=k;
	p是一个序列：p=<p0,p1,...,pn>
```



```c
//自底向上方法
	MATRIX-CHAIN-ORDER(p)
		n=p.length-1 //因为数组从0开始计
		let m[][],s[][] be new array
		for(int i=0;i<=n;i++)
			m[i][j]=0;
		for(l=2;l<=n;l++)	//l表示矩阵链的长度；自底向上，我们先求解最短链的最优解，才能逐步向上求解
			for(int i=0;i<=n-l+1;i++) //i-标识该链的起始点矩阵
				j=i+l-1;	//j-该链的最后一个矩阵下标
				m[i][j]=-∞
				for(int k=i;k<=j;k++)
					q=m[i][k]+m[k+1][j]+pi-1*pk*pj
					if(q<m[i][j])
						m[i][j]=q
						s[i][j]=k
		
		return m,s
```

```c
//构造输出最优解
	PRINT-OPTIMAL-PARENS(s,i,j) //paren:圆括号
	if(i==j) Print "A";
	
	printf("(")
	PRINT-OPTIMAL-PARENS(s,i,s[i][j])
	PRINT-OPTIMAL-PARENS(s,s[i,j]+1,j)
	printf(")")
	
```

```c
//递归方法；不带备忘的做法；递归树中相同的子问题，总是重复分解计算
	MATRIX-CHAIN(p,i,j)//把m[][] ,s[][]作为全局来使用
		if(i==j) return m[i][j]=0
		else
			m[i][j]=∞
			for k=i to j-l
				q=MATRIX-CHAIN(p,i,k)+MATRIX-CHAIN(p,k+l,j)+p_i-1 *p_k *p_j 
				if q<m[i][j]
				m[i][j]=q
				s[i][j]=t+l
			
			return m,s；
```

```c
//带备忘递归-课本分成两个；把m[][]初始化为∞抽出来
	MATRIX-CHAIN(p,i,j)
		if(i==j) return m[i][j]=0 
		
		if m[i][j]！= ∞ 
			return m[i][j] // 假设m[][]初始化为∞
		                       
			for k=i to j-l
				q=MATRIX-CHAIN(p,i,k)+MATRIX-CHAIN(p,k+l,j)+p_i-1 *p_k *p_j 
				if q<m[i][j]8ji8j
				m[i][j]=q
				s[i][j]=t+l
			
			return m,s；
```



### 04 最长公共子序列问题LCS

​	X=<x1,..,xm>
​	Y=<y1,...,yn>
​	Z=<z1,...,zk>
​	**子序列的定义**；

```c
 c[i,j]表示长度为i,j的两个子序列的 LCS 的长度
		 c[i,j]=c[i-1,j-1]+1 ; xm=yn
		 c[i,j]=max{c[i-1,j],c[i,j-1]}
		 c[0,1]=0
		 c[1,0]=0
		 c[0,0]=0
		 
```

```c
//自底向上
	LCS-LENGTH(X,Y)
		for i=0 to m
			c[i,0]=0
		for j=0 to n
			c[0,j]=0
		
		for i=1 to X.length
			for j=1 to Y.length
				if(X[i]==Y[j])
					c[i,j]=c[i-1,j-1]+1
				else
					c[i,j]=max{c[i-1,j],c[i,j-1]}
		
		return c;
```

```c
//自底向上+路径保存
	//自底向上
	LCS-LENGTH(X,Y)
		for i=0 to m
			c[i,0]=0
		for j=0 to n
			c[0,j]=0
		
		for i=1 to X.length
			for j=1 to Y.length
				if(X[i]==Y[j])
					c[i,j]=c[i-1,j-1]+1
					b[i,j]="左上箭头"
				else if c[i-1,j]>c[i,j-1]
					c[i,j]=c[i-1,j]
					b[i,j]="左箭头" //假设表i是表示第i行;j表示第j列；左上是原点[0,0]； 怎么保存打印取决于表
				else 
					c[i,j]=c[i,j-1]
					b[i,j]="上箭头"
		
		return c，b;
```

```c
//递归打印(构造)LCS
	PRINT-LCS(b,X,i,j) //起始调用 PRINT-LCS(b,X,X.length,Y.length); 只需要寻找X的最长子序列轨迹
		if(i=0||j==0) return 0
		
		if(b[i][j]="左上箭头")
			PRINT-LCS(b,X,i-1,j-1)
			//print"左上箭头" //不用打箭头，只打序列
			print x[i]	// 只有这种情况是公共的子序列！需要打印
		else if(b[i][j]="上箭头")
			PRINT-LCS(b,X,i-1,j)
			//printf(x[i])
		else
			PRINT-LCS(b,X,i,j-1)
```

	/*实际上可以不用表b；因为每次可以通过查表c中 c[i-1，j-1]、c[i-1,j]、c[i,j-1]三个值，
	在O(1)判断出在计算c[i,j]时使用了哪一项，等价于查表b
	三者谁大取谁；优先取c[i-1,j-1]
	*/



## 图算法

### DFS 算法

算法导论中，将图的路径抽象为“树边、前向边、反向边，交叉边”等概念，来描述DFS算法的特征和性质。

**边的分类**：DFS时，边第一次执行（u,v）v的颜色决定了边的类型

基本图的DFS算法：由 DFS(G) 和 DFS-VISIT(G,s)

```c
//深度优先搜索;邻接表
	DFS-VISIT(G,s) // G-无向图、s为根 ;从给定根做一次DFS搜索-相当于树的情况
		time+=1;  // *！进来之前，结点一定是white
		s.color = grey;
		s.st = time;
		
		for each v belong adj[s]
			if(v.color == white)
				v.p = s
				BFS(G,v)
			if(v.color == grey) //无向图只有反向边(指向祖先结点) 和 树边 ； 无前向边（指向后代-非树边）
				print"有环" //注意有环判断的时间复杂度0(|V|),这个代码可以实现有环判定，但实际如果要判定无向图是否有环，可以更快；一次DFS-VISIT算法在发现环之前，最多只会遍历|v|条边
		v.color = black;
		time+=1;// *！每次遍历完一个结点的全部邻接结点，回溯时间要+1；从结构看，因为是DFS，越深的结点是先遍历完的
		v.ft = time; 
```

### DFS求连通图个数

```c
//求有多少个连通图
	DFS(G)
		for all v belong G.V
			v.color = white
			v.p = null; //父亲结点
			v.st = 0;
			v.ft = ∞;
		for all v belong G.V
			if(v.color == White)
				num++;
				BFS-VISIT(G,v)
```

### DFS应用

​	01-无限图G是否连通问题？调用一次DFS-VISIT,如果还有结点是WHITE,则不连通	; O(|V|+|E|)
​	02-寻找无向图连通分支？每执行一次DSF-VISIT得到1个连通分支；可以再增加数组为每个结点做标记；在num++处，满足black 且 标记为0，为一个连通；收集并标记为1 ; O(|V|+|E|)
​	03-无向图G是否是1棵树？注意是树，不包括森林；那么看由美亚反向边-成环则不是； 看是不是森林-连通吗； O(|v|)

```c
//深度优先搜索;有向图-邻接表(可能存在前向边-画出图好理解； 交叉边)
	DFS-VISIT(G,s) // G-有向图、s为根 ;从给定根做一次DFS搜索-相当于树的情况
		time+=1;  // *！进来之前，结点一定是white
		s.color = grey;
		s.st = time;
		
		for all v = adj[s]
			if(v.color == white)
				v.p = s
				BFS(G,v)
			if(v.color == grey) //无向图只有反向边(指向祖先结点) 和 树边 ； 无前向边（祖先指向后代-非树边）
				print"有环"
		v.color = black;
		time+=1;// *！每次遍历完一个结点的全部邻接结点，回溯时间要+1；从结构看，因为是DFS，越深的结点是先遍历完的
		v.ft = time; 
	
	//成不成环问题，与无向图的处理方法是一样的
```



### DFS解强连通图问题

求有多少个强连通图（连通性问题）-不能按照无向图的方法了
	强连通图问题：
		**01-做一遍DFS(G)算法；**
		**02-将G转置得GT(V,ET)**
		**根据02，根据|V|中结点v.ft的顺序**
		**在GT(V,ET)中执行 DFS-VISIT算法；每次挑还是白色的结点；**
		**每次DFS-VISIT得到的就是有向图的1个连通图**



### DFS-拓扑排序

```c
//其它应用
	拓扑排序-利用DFS做：
		0a-当一个结点DFS访问结束，添加到链表中，最后返回链表
		0b-对结点按访问结束时间从大到小输出，就是1个拓扑排序
		O(|V|+|E|)
		
```

### BFS算法

广度优先搜索BFS
基本思想：先找距离源点距离为k的结点，再找距离(k+1)的结点

```c
BFS(G) // 以为s为根
			for all v belong |V|
				v.color = white
				v.p = null;
				v.d = ∞;
			
			for(all v belong |V|)
				if v.color = white
					v.d = 0
					BFS-VISIT(G,v)
		
```

```c
			
	BFS-VISIT(G,r) // 以r为根 ; 求s-t距离；直接调用BFS-VISIT(G,s) //然后再对代码做小小修改
			r.color = grey
			Q.ENQUEUE(r)
			
			while Q.isEMPTY==false
				u=Q.DEQUEUE
				visist"u"
				for all v belong to G.adj[u]
					if(v.color == white)
						v.d=u.d+1;
						v.p=u
						v.color = grey
						Q.ENQUEUE(v)
				
				u.color = black
			
			return G
```

通过BFS可以得到：
		从某点出发到其它结点的最短路径
		以s为根的BFS树（前提是不成环、连通，求一个连通子图，有结点被指定为根）
		邻接表存储图，BFS算法时间复杂度为 O(|V|+|E|); 若是邻接矩阵，则为O(|V|^2)

### 最小生成树算法（Kruskal和 Prime）

**思想**

每次从未选边集选不成环的边；(算法结束，是否包括所有点，是则成功)一般对象是连通的（无向图）

01-初始化：每个结点为1个连通分支
02-对于两个连通分支，选择他们的权值最小的边，合并这两个连通分支，重复这一过程
		利用并查集：MAKE-SET(v) 、FIND-SET(v) 、UNION(u,v) 
		输入：加权连通图
		输出ET

```c
MST-KRUSAL(G,w) //w保存了边的权重信息
			for v belong to all G.V
				MAKE-SET(v)
				
			sort the G.E in increasing order using input w 
			
			for each (u,v) belong to G.E
				if FIND-SET(u)!=FIND-SET(v)
					UNION-SET(u,v)  //最高时间复杂度可以达到 O(|lgV|)
					A=A∪{(u,v)} // A保存边集
			
			return A
			
		//时间复杂度：O(|E|lg|V|)
```

**相关算法：并查集**

```c
并查集由一个个不相交（领主不同）的集合构成S={S1,S2,...,Sk}
		具有3个操作
			MAKE-SET(x): Si={x}，S=S∪{x}  //O(1)
			FIND-SET(x)	//O(1)
			UNION(x,y)  //O(n)
		//基于并查集求无向图中所有连通分支-对比DFS方法\BFS方法
		CONNECTED-COMPONENTS(G)
			for each v belong to G.V
				MAKE-SET(v)
			for each edge (u,v) belong to G.E
				if(FIND-SET(u)==FIND-SET(v))
					UNION(u,v)
			count how many SET in S //统计S中有多少个集合就可知有多少个连通图
			
		//实现并查集的数据结构设计，可以用链表实现；
```



### Prime算法

**思想：**

01-创建一颗局部树VA并不断增长
02-每次选一条权值最小的边(选边也是选点)，这条边要连接局部树和未在局部树(V-VA)中的结点

**分析:**

01-使用数据结构"优先队列-Q"来实现（上面已总结）
02-优先队列元素是结点,属于{V-VA}，记为v；局部树{VA}结点记为(u,v)
	  优先队列基于最小堆实现，每个元素(结点)的key值是v到u中所有边中权值最小那条边的权值
03-EXTRACT-MIN(Q) 表示从Q中取出当前key最小的结点

```c
PRIM(G,w,r) //w 保存了每条边的权值
			Q=空集合 // Q用来表示一个最小优先队列
			for each v belong G.V
				v.p = null //指向结点在生成树中的父结点- 用来保存"MST"结构信息的
				v.key = ∞
				Q.insert(v)
			DECREASE-KEY(Q,r,0)	// 选择图中一个节点r,将其key置为0，则r默认为MST-TREE的根 ； 所以r 已知！
			while Q.isEMPTY ==false 
				u = EXTRACT-MIN(Q) // EXTRACT-MIN(Q): 1-取Q中key最小元素(第；2- 将u从Q删除 ； 根据上面，第一次取的是r
				for each v belong to G.Adj[u] //看需不需要修改
					if(v belong to Q && w(v,u)<v.key) //因为u已经加入了VA
						v.p = u //常规的邻接表，是没有v.p这个域的 			//Q1:有些结点的指针p不会修改，对吧？
						DECREASE-KEY(Q,v,w(u,v))
						
			
			//时间复杂度：O(|E|lg|V|)
			//Q2：仅靠当前信息，无法很好的还原MST树
```



# 经典排序算法

## 快速排序

- 思想：每一趟快排确定一个元素的最终位置
- 确定一个哨兵，确定哨兵的位置
- 确定pos的过程，可以写一个partition函数，当然也可以不用
- 特殊情况：全有序，有重复元素，元素全相等

````java
 public void quickSort(int[] nums,int l,int r){
        if(r<=l) return ;
        int i=l,j=r;
        int temp=nums[i];
        while(i<j){
            while(i<j && nums[j]>=temp) j--; //nums[j]>=temp 必须带等号，否则对于有重复数组的情况，可能会死循环。e.g.nums{1,2,5,6,36,7,7,122,34,3},nums[5]=nums[6]=1，会一直停留在i=5,j=6
            nums[i]=nums[j];
            while(i<j && nums[i]<=temp) i++;
            nums[j]=nums[i];
        }
        nums[i]=temp;
        quickSort(nums,l,i-1);
        quickSort(nums,i+1,r);
    }
````





# OJ

## 数组

### 将数组的0元素移动到最后

题目：

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:

必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。

我的解法：

````java
class Solution {
    public void moveZeroes(int[] nums) {
       
        int f,length=0;
        for(int i=0;i<nums.length;i++){

            if(nums[i]!=0 && length!=0){
                int temp = nums[i];
                nums[i] = nums[i-length];
                nums[i-length] = temp;
                f = i;
                continue;
            }

            if(nums[i]==0){
                length++;
                f =i;
                continue;
            }
        }
        
    }
}
````

更好一点的解法，即只需要考虑一直一交换与不交换就好·

````java
class Solution {
    public void moveZeroes(int[] nums) {
        int n = nums.length, left = 0, right = 0;
        while (right < n) {
            if (nums[right] != 0) {
                swap(nums, left, right);
                left++;
            }
            right++;
        }
    }

    public void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/move-zeroes/solution/yi-dong-ling-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
````



### 求股票的最佳卖出时机I-III

I-题目描述：


给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

 

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

题解一：求出最大最小值，递归划分数组

`````java
/**
时间复杂度：O(nlg(n))
空间复杂度：O(nlg(n))

*/
class Solution {
    public int maxProfit(int[] prices) {
        return calmaxProfit(prices,0,prices.length-1);

    }
    public int calmaxProfit(int[] prices,int start ,int end){
        if(start >= end) return 0; 
       
        int maxIndex =start , minIndex =end;
        for(int i=start ; i<=end ; i++){
            if(prices[i]>=prices[maxIndex]){
                maxIndex = i;
            }
            if(prices[i]<prices[minIndex]){// 注意，这一 < 是为了最小值尽可能取左边元素
                minIndex = i;
            }  
        }

        if(minIndex<maxIndex) return prices[maxIndex]-prices[minIndex];

        //分割原来数组[start,maxIndex][maxIndex,minIndex][minIndex,end]
        int tMin =Integer.MAX_VALUE;
        int profitT1 = 0;
        for(int i=start ; i<=maxIndex ;i++){
            if(prices[i] <= tMin) tMin = prices[i];
        }
        profitT1 = prices[maxIndex]-tMin;

        int profitT2 = calmaxProfit(prices,maxIndex+1 ,minIndex-1);
        
        int tMax =Integer.MIN_VALUE;
        int profitT3 = 0;
        for(int i=minIndex ; i<=end ;i++){
            if(prices[i] >= tMax) tMax = prices[i];
        }
        profitT3 = tMax-prices[minIndex];

        int maxProfit = profitT1 >= profitT2 ? (profitT1 >= profitT3 ? profitT1: profitT3) : (profitT2 >= profitT3 ? profitT2 : profitT3);
        return maxProfit;
    }
           
}
`````

题解2： **最好的解法**: 求最小值------->假设是在历史最低点买入



```` java
public class Solution {
    public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice) {
                minprice = prices[i];
            } else if (prices[i] - minprice > maxprofit) {
                maxprofit = prices[i] - minprice;
            }
        }
        return maxprofit;
    }
}


````

II-题目描述

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

`````java
/**
原问题等价于：
对于股票prices[]对应的折线图，寻找全部的单调递增子区间，在每个单调递增子区间起始点买入，最高点卖出
*/

class Solution {
    public int maxProfit(int[] prices) {
        int profit=0;
        int upStart=0;
        int upEnd = 0;
        for(int i=1 ; i<prices.length ;i++){
            if(prices[i]>=prices[i-1]){
                upEnd = i;
                if(i == prices.length -1) profit += (prices[upEnd] - prices[upStart]);
                else continue;
            }else{
                profit += (prices[upEnd] - prices[upStart]);
                upStart = i;
                upEnd = i;
            }
        }
        return profit;

    }
}
`````

`````java
//贪心的把每一段上升加起来就好 ； 更简洁
class Solution {
    public int maxProfit(int[] prices) {
        int ans = 0;
        int n = prices.length;
        for (int i = 1; i < n; ++i) {
            ans += Math.max(0, prices[i] - prices[i - 1]);
        }
        return ans;
    }


`````



### 双指针思想-三数之和

**题目描述**：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。

**关键思想**：

- 由于要求不重复，是枚举，想到先排序
- **双指针思想**：虽然是3重循环，但第二重和第三重是并列的。$$对 a+b+c=0 ; 固定a，寻找b和c时，对于满足条件的b，c；因为b'>b，所以一定有c'<c$$，由均摊关系可知，第二，第三重循环之际上只有O(n)的时间复杂度

**复杂度**

- $O(n^2)$ , $O(N)-排序$

**代码**

`````java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int n = nums.length;
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        // 枚举 a
        for (int first = 0; first < n; ++first) {
            // 需要和上一次枚举的数不相同
            if (first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }
            // c 对应的指针初始指向数组的最右端
            int third = n - 1;
            int target = -nums[first];
            // 枚举 b
            for (int second = first + 1; second < n; ++second) {
                // 需要和上一次枚举的数不相同
                if (second > first + 1 && nums[second] == nums[second - 1]) {
                    continue;
                }
                // 需要保证 b 的指针在 c 的指针的左侧
                while (second < third && nums[second] + nums[third] > target) {
                    --third;
                }
                // 如果指针重合，随着 b 后续的增加
                // 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环
                if (second == third) {
                    break;
                }
                if (nums[second] + nums[third] == target) {
                    List<Integer> list = new ArrayList<Integer>();
                    list.add(nums[first]);
                    list.add(nums[second]);
                    list.add(nums[third]);
                    ans.add(list);
                }
            }
        }
        return ans;
    }
}

`````

````java
public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> resList = new ArrayList<>();
        quickSort(nums,0,nums.length-1);
        System.out.println("sorted:"+Arrays.toString(nums));
      //  Arrays.sort(nums);

        for(int i=0;i<nums.length-2;i++){
            int resSum= 0 - nums[i];
            int indexC = nums.length-1;
            for(int j=i+1;j<indexC;j++){ //细节1
                //确定indexC,初始为
              //  if(nums[indexC]+nums[j]< resSum && indexC>j) continue;
                while(nums[indexC]+nums[j]>resSum && indexC>j)  indexC--;
                if(nums[indexC]+nums[j] == resSum && indexC>j){ //细节2：注意判断 indexC>j ;从循环出来，一定要注意可能的取值
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[j]);
                    list.add(nums[indexC]);
                    if(!resList.contains(list)){
                        resList.add(list);
                    }

                }
            }
        }
        return resList;

    }
    //复习一下快排，顺便和使用Arrays.sort()的性能对比一下，嘿嘿
    public void quickSort(int[] nums,int l,int r){
        if(r<=l) return ;
        int i=l,j=r;
        int temp=nums[i];
        while(i<j){
            while(i<j && nums[j]>=temp) j--; //nums[j]>=temp 必须带等号，否则对于有重复数组的情况，可能会死循环。e.g.nums{1,2,5,6,36,7,7,122,34,3},nums[5]=nums[6]=1，会一直停留在i=5,j=6
            nums[i]=nums[j];
            while(i<j && nums[i]<=temp) i++;
            nums[j]=nums[i];
        }
        nums[i]=temp;
        quickSort(nums,l,i-1);
        quickSort(nums,i+1,r);
    }
````



### 双指针思想-三数之和接近某个值

**题目描述**

给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。

**思路与三数之和为0对比**

```
/*不同于三数之和的题目，a+b+c=0 ,在第二个for循环里面，b从最小开始增大，c从最大开始减少，固定b，找到一个c时，
* 由于下一个值b‘>b，要使得和为0，c'一定小于c
* 在本题中，是求最接近的值，且题目说了唯一；
* 那么找到a+b+c=0，直接return j
* 对于一对b,c值，通过判定是否更接近target，来觉得是否采纳这对b和c;
* 不管接纳与否，如何寻找下一对b和c是这样的（本题双指针的移动逻辑）：
* a+b+c > target ,c减少(indexC--) ;增加b无意义
* a+b+c < target ,b增加
* 每次移动b和c,都要做这样的判定；
* 同样，这样的时间复杂度是o(n^2)；
* */
```

我的题解

````java
public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        //System.out.println(Arrays.toString(nums));
        int minAbsDiffer = Integer.MAX_VALUE;
        int res=0;
        for(int i=0;i<nums.length-2;i++){
            if( i>0 && i<nums.length-2 && nums[i]==nums[i-1]) continue; //寻找不重复元素
            int remainSum = target - nums[i];
            int indexThird = nums.length-1;
            int j = i+1;
            while(j<indexThird){
                if(Math.abs(nums[j]+nums[indexThird]-remainSum)< minAbsDiffer){
                    res = nums[j]+nums[indexThird] +nums[i];
                    minAbsDiffer = Math.abs(res- target);
                }
            
                if(nums[i]+nums[j]+nums[indexThird]>target){
                    indexThird--;
                }else{
                    j++;
                }

            }
        }
        return res;
    }
````

参考题解

````java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int n = nums.length;
        int best = 10000000;

        // 枚举 a
        for (int i = 0; i < n; ++i) {
            // 保证和上一次枚举的元素不相等
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            // 使用双指针枚举 b 和 c
            int j = i + 1, k = n - 1;
            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];
                // 如果和为 target 直接返回答案
                if (sum == target) {
                    return target;
                }
                // 根据差值的绝对值来更新答案
                if (Math.abs(sum - target) < Math.abs(best - target)) {
                    best = sum;
                }
                if (sum > target) {
                    // 如果和大于 target，移动 c 对应的指针
                    int k0 = k - 1;
                    // 移动到下一个不相等的元素
                    while (j < k0 && nums[k0] == nums[k]) {
                        --k0;
                    }
                    k = k0;
                } else {
                    // 如果和小于 target，移动 b 对应的指针
                    int j0 = j + 1;
                    // 移动到下一个不相等的元素
                    while (j0 < k && nums[j0] == nums[j]) {
                        ++j0;
                    }
                    j = j0;
                }
            }
        }
        return best;
    }
}

````



### *双指针思想-四数之和

题目描述

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：答案中不可以包含重复的四元组。



示例 1：

输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
示例 2：

输入：nums = [], target = 0
输出：[]



代码

题解

````JAVA
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> quadruplets = new ArrayList<List<Integer>>();
        if (nums == null || nums.length < 4) {
            return quadruplets;
        }
        Arrays.sort(nums);
        int length = nums.length;
        for (int i = 0; i < length - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) { //枚举不一样的第一个数,用if...continue 好过用 while
                continue;
            }
            //考虑两种情况，可以加速寻找
            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {
                break;
            }
            if (nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target) {
                continue;
            }
            
            for (int j = i + 1; j < length - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) {//枚举不一样的第二个数,用if...continue 好过用 while
                    continue;
                }
                 //考虑两种情况，可以加速寻找
                if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {
                    break;
                }
                if (nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target) {
                    continue;
                }
                //双指针将两重循环合并为一重
                int left = j + 1, right = length - 1;
                while (left < right) {
                    int sum = nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum == target) {
                        quadruplets.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));
                        while (left < right && nums[left] == nums[left + 1]) {
                            left++;
                        }
                        left++;
                        while (left < right && nums[right] == nums[right - 1]) {
                            right--;
                        }
                        right--;
                    } else if (sum < target) {
                        left++;
                    } else {
                        right--;
                    }
                }
            }
        }
        return quadruplets;
    }
}
````



我的

`````java
public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        List<List<Integer>> ansList = new ArrayList<>();
        for (int i = 0; i < nums.length - 3; i++) {
            //寻找不一样的i
            while (i > 0 && i<nums.length - 3 && nums[i] == nums[i - 1]) i++; // && i<nums.length - 3 为了数组元素都一样时，判定时数组下标越界
            for (int j = i + 1; j < nums.length - 2; j++) {
                //寻找不一样的j
                while (j > i + 1 && j<nums.length-2 && nums[j] == nums[j - 1]) j++; //&& j<nums.length-3 为了数组元素都一样时，判定时数组下标越界

                int index_t = nums.length - 1;
                for (int k = j + 1; k < index_t; k++) {
                    //寻找不一样的K
                    while (k > j + 1 && k<index_t &&  nums[k] == nums[k - 1]) k++;

                    int z = index_t;
                    while( z>k){
                        if (nums[i] + nums[j] + nums[k] + nums[z] == target) {
                            List<Integer> ans = new ArrayList<>();
                            ans.add(nums[i]);
                            ans.add(nums[j]);
                            ans.add(nums[k]);
                            ans.add(nums[z]);
                            ansList.add(ans);
                            index_t = z-1;
                            break;
                        }
                        z--;
                    }

                }
            }
        }
        return ansList;
    }
`````



### 二分查找搜索选择数组

**题目描述**

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

````txt
示例 1：
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
示例 2：
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
示例 3：
输入：nums = [1], target = 0
输出：-1
````

**思路分析**

- 目的能够实现 $O(log(n))$的时间复杂度

- **利用**：在不断二分数组时，总有一半数组是有序的 这个性质，缩小检索范围，接下来就是不断二分查找的过程
- 代码中while(l<=r) , 必须带 = ，否则结果只能是 找不到



**代码**

````java
package Hot100.Medium;

public class SoSearchReverseArray13 {
    public int search(int[] nums,int target){
        int r = nums.length-1;
        int l = 0;

        if(r == -1) return -1;
        if(r ==0 ){
            return nums[r] == target ? 0:  -1;
        }

        while(l<=r){ //l<=r , 如果存在target ，二分到最后就是 l=r 的情况
            int mid = (l+r)/2;
            if(nums[mid] == target) return mid;
            if(nums[l]<=nums[mid]){ // 确定[l,mid) 有序
                if(nums[l]<=target && target <nums[mid] ){
                    r = mid -1 ;
                }else{
                    l = mid + 1;
                }

            }else{ //确定(mid,r) 有序
                if(nums[r]>=target && target>nums[mid]){
                    l = mid +1;
                }else{
                    r = mid -1;
                }
            }
        }
        return -1;

    }
}
````



**复杂度**

- $O(log(n))，O(1)$



### 二分查找专项

题目：给定一个数组，查找target 在nums[ ]的下标。

知识点：

- 普通二分查找

  - while(left <= right) ：出循环时: [left,right] ,left>right
  - while(left < right) : 出循环时： [left,left)，要多检查nums[left]这个值

- 寻找目标值最左index的二分查找

  - ```java
    ...
    while(left < right){ //用不等的条件，我们不想一找到target就返回
        ...
        int mid = (left + right) / 2;
    	...
    	if (target == nums[mid]) {
                    right = mid;
                    left = left; //缩小区间继续找[left不变-包括左边可能有的元素, right缩小到mid-保证至少有解]
                } 
     
        ...   
    }    
    
    ```

    

- 寻找目标值最右index的二分查找

  - ```java
    ...
    while (left < right) {
         ...
    	int mid = (left + right) / 2 +1; 
    	// 相比较于寻找最左Index,这里要向右取整，否则会死循环, e.g. L=3,R=4 ,nums[L]=nums[R]=target  情况
    	...
    	if (target == nums[mid]) {
                    left = mid;
                    right = right; //思想和左区间类似   
    	...
    }
    ```

完整代码：

````java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if(nums.length == 0) return new int[]{-1,-1};

        int leftIndex = binaryLeftSearch(nums,target);
        int rightIndex = binaryRightSearch(nums,target);
        return new int[]{leftIndex,rightIndex};

    }
    private int binaryLeftSearch(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while (left < right) { //[left,left),出循环时left = right
            int mid = (left + right) / 2;

            if (target == nums[mid]) {
                right = mid;
                left = left; //缩小区间继续找[left不变包括左边可能有的元素, right缩小到mid至少有解]
            } else if (target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }

        }
        if (nums[left] == target) return left;
        else return -1;

    }

    private int binaryRightSearch(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while (left < right) { //[left,left),出循环时left = right
            int mid = (left + right) / 2 +1; // 相比较于寻找最左Index,这里要向右取整，否则会死循环, e.g. L=3,R=4 ,nums[L]=nums[R]=target  情况

            if (target == nums[mid]) {
                left = mid;
                right = right; //缩小区间继续找[left不变包括左边可能有的元素, right缩小到mid至少有解]
            } else if (target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }

        }
        if (nums[right] == target) return right;
        else return -1;
    }

}
````



结果

![image-20210707114220234](mdPics/image-20210707114220234.png)





### 在二维数组上做二分查找

**题目**

- <img src="mdPics/image-20210727144014970.png" alt="image-20210727144014970" style="zoom: 67%;" />

- **思路**

  - 先二分确定行，再在这个行上二分确定列。$O(logm+logn)=log(mn)$
  - 看作一纬的数组直接二分，要求是规范的二维数组(没行元素一样)。$O(logmn)$

- **代码**

  - ````java
    public boolean searchMatrix(int[][] matrix,int target){
            int m = matrix.length;
            int n = matrix[0].length;
            int low =0;
            int high = m*n-1;
            while(low<=high){
    
                int mid = (low+high) /2 ;
    
                if(matrix[mid/n][mid%n] == target){
                    return true;
                }else if(matrix[mid/n][mid%n] < target){
                    low = mid +1 ;
                }else high = mid-1;
    
            }
            return false;
    
        }
    ````

  - <img src="mdPics/image-20210727144233892.png" alt="image-20210727144233892" style="zoom:50%;" />

  

### 数组合并

**题目描述**

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

 

示例 1：

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2：

输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。


提示：

1 <= intervals.length <= 104
intervals[i].length == 2
0 <= starti <= endi <= 104

**思路 **

- 要想最快合并，利用贪心的思想只遍历一遍数组。这么做需要先对每个区间排序，按照区间左端点升序排序。题目并没有说区间都是有序的

- 排序实现：自定义一个比较器即可

- 在区间按照左端点升序的基础下，合并思路：

  - 维护两个值，当前扫过的区间的左右界，leftMost 和 rightMost

  - 从左往右，当间区间能否合并到前面区间的条件是：$$rightMost >= intervals[i][0]$$ 是否成立

  - 成立则能合并，更新rightMost:$$rightMost= intervals[i][1]>rightMost ? intervals[i][1]: rightMost $$

    - 做这个判断是因为要合并区间的右端点不一定就比前面的区间的右端点值大

  - 不成立则不能合并，建立一个区间解$[leftMost, rightMost]$并更新左右界的值

    - ````java
      int[] oneRange = new int[2];
                      oneRange[0]= leftMost;
                      oneRange[1]= rightMost;
                      ans.add(oneRange);
                      leftMost = intervals[i][0];
                      rightMost = intervals[i][1];
      ````



**代码**

````java
public int[][] merge(int[][] intervals){
        Arrays.sort(intervals,new ArrayComparator());
        List<int[]> ans = new ArrayList<>();

        int leftMost=intervals[0][0],rightMost = intervals[0][1];
        int i;
        for(i=0;i<intervals.length;i++){
            if(rightMost >= intervals[i][0]){
                rightMost= intervals[i][1]>rightMost ? intervals[i][1]: rightMost ;
                //易忽略情况[[1,6],[2,4],[7,9]] ->[1,6] [7,9] 而非 [1,4] [7,9]
                continue;
            }else{ //
                int[] oneRange = new int[2];
                oneRange[0]= leftMost;
                oneRange[1]= rightMost;
                ans.add(oneRange);
                leftMost = intervals[i][0];
                rightMost = intervals[i][1];

            }

        }
        int[] oneRange = new int[2];
        oneRange[0] = leftMost;
        oneRange[1] = rightMost;
        ans.add(oneRange);

        int[][] ansArr = new int[ans.size()][];
        return ans.toArray(ansArr);
    }
````



### [插入区间](https://leetcode-cn.com/problems/insert-interval/)

**题目描述**

给你一个 无重叠的 ，按照区间起始端点排序的区间列表。

在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。

 

示例 1：

输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
输出：[[1,5],[6,9]]
示例 2：

输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
输出：[[1,2],[3,10],[12,16]]
解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。
示例 3：

输入：intervals = [], newInterval = [5,7]
输出：[[5,7]]
示例 4：

**思路**

- 区间有交集的条件是什么？
- <img src="mdPics/image-20210719105758015.png" alt="image-20210719105758015" style="zoom: 67%;" />
- 

<img src="mdPics/image-20210719110053717.png" alt="image-20210719110053717" style="zoom:67%;" />



**代码**（巧）

````java
public int[][] insert(int[][] intervals, int[] newInterval) {
        int left = newInterval[0];
        int right = newInterval[1];
        boolean place = false;
        List<int[]> ans = new ArrayList<>();
        for(int[] interval : intervals){
            if(right < interval[0]){
                //在插入区间的右侧且无交集
                if(!place){
                    ans.add(new int[]{left,right});
                    place = true;
                }
                ans.add(interval);

            }else if(interval[1] < left){
                //在插入区间的左边
                ans.add(interval); //这里这样处理就可以，只插入正常区间，插入区间的处理 归约在另外2种情况处理中
            }else{
                // 与插入区间有交集，计算他们的并集
                left = Math.min(left,interval[0]);
                right = Math.max(right,interval[1]);
            }
        }

        if(!place){ //只剩一种情况
            ans.add(new int[]{left,right});
        }
        int [][]Arr = new int[ans.size()][];
        return ans.toArray(Arr);


    }
````





## 树

### 两棵树合并

思路：

可以使用深度优先搜索合并两个二叉树。从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。

两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。

如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；

如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；

如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。

对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过

```` java
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == null) {
            return t2;
        }
        if (t2 == null) {
            return t1;
        }
        TreeNode merged = new TreeNode(t1.val + t2.val);
        merged.left = mergeTrees(t1.left, t2.left);
        merged.right = mergeTrees(t1.right, t2.right);
        return merged;
    }
}
````



### 将有序数组转换为平衡二叉搜索树

题目：给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。



分析：

1.相关性质熟悉。二叉搜索树，左小右大；平衡树的相关概念

2.二叉搜索树的中序遍历是递增的；所以 升序 的nums数组，是要构建的树的中序遍历；

3.给定一棵树的中序遍历，无法唯一确定一棵树。同样，再加上一个限制条件，平衡的二叉搜索树，同样该树是不唯一的，所以答案有多种；

4.以下面的策略，便可构造题目要求的树：从nums数组取出根结点。nums.length 是奇数，呢么根结点是确定，否则，构建的树情况有多种，取决于根结点的选择；eg.[1,3,5,7] 可以选择3为根，也可以选择5为根

5.由于数组是升序的，二叉搜索树左小右大的性质，选出根结点后，便可以递归的构造目标树。

```` java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
//我的题解：
//空间复杂度：会传建子数组，子数组个数2*log(n) ,每个长度O(n)； 所以空间复杂度O（nlog(n)）
//时间复杂度：O(n)； nums数组每个元素被取为root一次

class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        //递归终止条件
        if(nums.length == 1) {
            TreeNode leaf = new TreeNode(nums[0]);
            return leaf; 
        } 
        if(nums.length == 0)  return null;

        int rootNum = nums[nums.length/2];
        TreeNode root = new TreeNode(rootNum);
        int[] lNums = Arrays.copyOfRange(nums,0,nums.length/2); //[start,end) , 所以不用-1
        int[] rNums = Arrays.copyOfRange(nums,nums.length/2+1,nums.length); 
        root.left = sortedArrayToBST(lNums);
        root.right = sortedArrayToBST(rNums);

        return root;

    }
}
//参考题解
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return helper(nums, 0, nums.length - 1);
    }

    public TreeNode helper(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }

        // 总是选择中间位置左边的数字作为根节点
        int mid = (left + right) / 2;

        TreeNode root = new TreeNode(nums[mid]);
        root.left = helper(nums, left, mid - 1);
        root.right = helper(nums, mid + 1, right);
        return root;
    }
}

//时间复杂度：O(n)，其中 n 是数组的长度。每个数字只访问一次。

//空间复杂度：O(\log n)，其中 n是数组的长度。空间复杂度不考虑返回值，因此空间复杂度主要取决于递归栈的深度，递归栈的深度是 //O(\log n)。

````



### *对称二叉树判定

题目描述：给两棵树，判断它们是不是镜像对称的。

解题思路：

**1-错误思路**：通过LNR和RNL遍历，判断遍历序列是不是相同。存在某种树，LNR和RNL结果一样，但部署镜象树

$eg：[1,2,2,2,null,2]$

2-递归解法：用两个指针指向两颗树，镜像移动，判断指针所指结点是否有相同的值。

````java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root,root);
    }

    public boolean check(TreeNode p1 , TreeNode p2){
        if(p1 == null && p2 == null) return true;

        if(p1 == null || p2 == null) return false;

        return p1.val == p2.val && check(p1.left,p2.right) && check(p1.right,p2.left);
    } 
}
````

$O(n) , O(n)$

因为遍历这棵树，树有n个结点，所以渐进时间复杂度是O(n)

空间复杂度和递归使用栈空间大小有关，这里递归层树不超过n（即使是单支树），每层只需要单位时间复杂度，故总空间复杂度是O(n)

3-非递归解法-迭代解法

我们用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？

**基于层次遍历算法实现。对于镜象树，如果是用层次遍历，层次遍历时从左到右，或者从右到左的应该是一样的。**

**利用这一点，对同一棵树，同时进行从左到右，从右到左的层次遍历，保存在 一个队列中，这样每次出队的两个元素，应该相同的。**

// 不能用不同时的方法。比如先从左到右层次遍历，保存遍历结点序列，再从右到左来一遍。这样会陷入错误解法1中的问题。解法3本质是和递归解法一样的，通过同时镜像遍历达到准确校验目的

初试时，根结点入队两次。

首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。

````java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
 //用中序遍历的两种形式 LNR 和 RNL ，对称则结果是一样的
 //难点：递归过程如何保存，用什么数据结构？
 //用数组保存显然不如ARRAY LIST 方便；只需要一直add 就可以了
class Solution {
    public boolean isSymmetric(TreeNode root){

        return check(root , root);

    }
    public boolean check(TreeNode l , TreeNode r){
        Queue<TreeNode> q = new LinkedList<TreeNode>();
        q.offer(l);
        q.offer(r);
              
        while(!q.isEmpty()){
            l = q.poll();
            r = q.poll();

            if(l==null && r==null) continue;
            if(l==null || r==null || l.val != r.val) return false;
           
            q.offer(l.left);
            q.offer(r.right);

            q.offer(l.right);
            q.offer(r.left);
        }  
        return true;   

    }
    
}
````



## *二叉树直径

题目描述：

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

 

示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]

基本思路：求每个结点的直径，取其中最大值。每个结点直径 = 左子树深度+右子树深度

````java
public class solution7 {
    private List<Integer> diameterOfNodeList = new ArrayList<>();

    public int diameterOfBinaryTree(TreeNode root) {
        traverseOfTree(root);
        int maxDia = Integer.MIN_VALUE;
        for (int i = 0; i < diameterOfNodeList.size(); i++) {
            if (diameterOfNodeList.get(i) >= maxDia) maxDia = diameterOfNodeList.get(i);
        }
        return maxDia;
    }

    public int traverseOfTree(TreeNode root) {
        if (root == null) return 0;

        int rDepth = 0;
        int lDepth = 0;

        if (root.left != null) {
            rDepth = traverseOfTree(root.left) + 1;
        }
        if (root.right != null) {
            lDepth = traverseOfTree(root.right) + 1;
        }
        diameterOfNodeList.add(rDepth + lDepth ); //记录直径
        return rDepth >= lDepth ? rDepth : lDepth; //求树深度
    }
}
````

代码简化

```java
class Solution {
    int ans;//定义在这里，全局使用
    public int diameterOfBinaryTree(TreeNode root) {
        ans = 1;
        depth(root);
        return ans - 1;
    }
    public int depth(TreeNode node) {
        if (node == null) {
            return 0; // 访问到空节点了，返回0
        }
        int L = depth(node.left); // 左儿子为根的子树的深度
        int R = depth(node.right); // 右儿子为根的子树的深度
        ans = Math.max(ans, L+R+1); // 计算d_node即L+R+1 并更新ans
        return Math.max(L, R) + 1; // 返回该节点为根的子树的深度
    }
}

```



****







## 链表

### 反转链表

边界条件的处理



### 合并两个升序链表

**方法一： 暴力合并**

无言。- 。 - 

```` java

class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode preHead = new ListNode(-1);
        ListNode pre = preHead;

        while(l1 != null && l2 != null){
            if(l1.val <= l2.val){
                pre.next = l1;
                pre = l1;
                l1 = l1.next;
            }else{
                pre.next =l2;
                pre = l2 ;
                l2 = l2.next;
            }
        }
        pre.next = l1==null ? l2:l1;
        return preHead.next;
    }
}
````

**方法二: 递归合并**

````java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 ==null && l2 ==null) return null;
        if(l1 == null && l2 !=null ) return l2;
        if(l1 != null && l2 == null) return l1;
        
        if(l1.val<=l2.val){
            l1.next = mergeTwoLists(l1.next,l2);
        }else{
            l2.next = mergeTwoLists(l1,l2.next);
        }
        
        return l1.val<=l2.val ? l1 : l2 ;

      
    }
}
````



### 寻找交叉链表的公共结点

题目描述：编写一个程序，找到两个单链表相交的起始节点。

````` java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
 
public class Solution{

    public ListNode getIntersectionNode(ListNode headA,ListNode headB){
        if(headA == null || headB == null) return null;

        ListNode scan1 = headA;
        ListNode scan2 = headB;
        int l1=0,l2=0;
        while(scan1 != null){
            l1++;
            scan1 = scan1.next;
        }
        while(scan2 != null){
            l2++;
            scan2 = scan2.next;
        }
        int distance = l1>=l2?(l1-l2):(l2-l1);
        //重置扫描指针
        scan1 = headA;
        scan2 = headB;

        //长度长的链表的扫描指针，先走distance距离
        if(l1>=l2){
            while(distance > 0){
                scan1 = scan1.next;
                distance--;
            }
        }else{
            while(distance > 0 ){
                scan2 = scan2.next;
                distance--;
            }
        }
        while(!scan1.equals(scan2) ){ //避免空指针调用方法的异常 
            scan1 = scan1.next;
            scan2 = scan2.next;
            if(scan2 == null || scan1 == null) break; //避免空指针；正常情况，如果找不到，scan1 和 scan2是同时为null的
        }
        
        return scan1 == null? null : scan1;  
    }   
}


`````

$O(n),O(1)$

<img src="mdPics/image-20210419221839374.png" alt="image-20210419221839374" style="zoom:50%;" />



### *判定链表是否有环

题目描述：给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 

<img src="mdPics/image-20210428095956964.png" alt="image-20210428095956964" style="zoom:50%;" />



解法一：使用哈希表；使用哈希表，将**ListNode**作为key

````java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
 //题目中的pos没有实际意味，只是为了解释这个题目
 
public class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> seen = new HashSet<ListNode>();
        while(head!=null){
            if(!seen.add(head)){
                return true;
            }
            head = head.next;
        }
        return false;
    }
}
````



解法二：快慢指针：

理解该算法理解的（包括时间复杂度分析）一个关键点：

因为指针有快慢，所以进入圈后，快追上慢最多只需要多走N个结点（头尾成环），时间复杂度是$O(n)$

**边界判定**：

本题的边界很有意思。在链表中移动指针一定要注意先注意空指针异常的判定。仔细体会

````java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
 //题目中的pos没有实际意味，只是为了解释这个题目
 
public class Solution {
    public boolean hasCycle(ListNode head) {

        if(head == null || head.next == null) return false;
        //要先上面判定，下面才能赋值

        ListNode slow = head;
        ListNode fast = head.next;
        
        //一样的道理，指针移动前要避免空指针异常
        while(fast != slow ){
            //成环，不能有后继Null
            if(fast == null || fast.next == null) return false; // fast 走得快，只要判断fast就

            slow = slow.next;
            fast = fast.next.next;  //新的fast可能是个null
        }

        return true;
        
    }
}
````



### *回文链的判定

题目描述：

请判断一个链表是否为回文链表。

示例 1:

输入: 1->2
输出: false
示例 2:

输入: 1->2->2->1
输出: true
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

1-用递归解

- 基本思路，利用递归的性质，先递归到最后结点然后开始比较
- 要实现这个算法，需要一个从前到后的“全局指针”，递归到最后一个结点后，开始比较。很简单，定义一个类字段就好了。
- 那么剩下的难点就在于，如何构造递归代码了；递归，其实是符合人的思维逻辑的
- $O(n),O(n)$

````java
private ListNode frontPoint = new ListNode();//递归之外的一个指针，作为类的字段来出现（类似-全局变量，对类而言）

    public boolean recursivelyCheck(ListNode currentNode){
        if(currentNode != null){
            if(!recursivelyCheck(currentNode.next)){ //首先要递归到最后，才能开始判断
                return false;
            }
            //不在往下递归，既本层，本结点的判定，与frontPoint所指的Node应该一样
            if(currentNode.val != frontPoint.val){
                return false;
            }
            frontPoint = frontPoint.next;

        }
        return true;
    }

    public boolean isPalindrome(ListNode head){
        frontPoint = head;
        return recursivelyCheck(head);
    }
````



解法2- 非递归解

- 基本思路:逆转后半部分-》比较-》恢复原链表。缺点是，这样的算法不适合并发程序。
- 先找到后半部分的头节点，我们定义前半部分长度》=后半部分。这样设计一个求前半部分最后一个的函数，更便捷。（恢复链表时）
- 使用到了原地反转单链表

````java
 public boolean isPalindrome(ListNode head){
        ListNode firstHalfNode = endOfFirstHalf(head);
        ListNode reverseSecondHalfHead = reverseList(firstHalfNode.next);


        //开始比较
        ListNode p1 = head;
        ListNode p2 = reverseSecondHalfHead;

        while(p2!=null){ //*该算法后面半部分的链表总是比较短的*
            if(p2.val != p1.val){
                return false;
            }
            p2 = p2.next;
            p1 = p1.next;
        }
        //恢复原来的链表
        firstHalfNode.next=reverseList(reverseSecondHalfHead);
        return true;

    }

    //通过快慢指针，可以确定后半部分的链表。不管是偶数长度还是奇数长度，我们都可以找到 后半部分的链表的头节点
    public ListNode endOfFirstHalf(ListNode head){
        ListNode fast = head;
        ListNode slow = head;

        while(fast.next!=null && fast.next.next!=null){ //链表-移动前先判空
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow ;
    }

    public ListNode reverseList(ListNode head){

        ListNode pre = null;
        ListNode currentNode = head;
        while(currentNode!=null){
            ListNode next = currentNode.next;
            currentNode.next = pre;
            pre = currentNode;
            currentNode = next;

        }
        return pre;
    }

````

### *两两交换链表的结点

**题目描述**

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

 ![image-20210612102334686](mdPics/image-20210612102334686.png)

示例 1：


输入：head = [1,2,3,4]
输出：[2,1,4,3]
示例 2：

输入：head = []
输出：[]
示例 3：

输入：head = [1]
输出：[1]

**思路1-迭代解(引入哑结点)**：

一直在想怎么统一各种情况...

统一的处理形式：

- 每次需要交换 `temp` 后面的两个节点。如果 `temp` 的后面没有节点或者只有一个节点，则没有更多的节点需要交换

- 实际上就是统一处理队头的情况

- 交换

  ````java
  temp.next = node1.next;
  node1.next = node2.next;
  node2.next = node1;
  ````

  

为此，才引入哑结点

**代码-1**

````java
//非递归解
    public ListNode swapPairs(ListNode head){
        ListNode dumpHead = new ListNode();
        dumpHead.next = head;
        ListNode temp = dumpHead;
        while(temp.next != null && temp.next.next != null){
            ListNode node1 = temp.next;
            ListNode node2 = temp.next.next;

            temp.next = node2;
            node1.next = node2.next;
            node2.next = node1;
            temp = node1;
        }
        return dumpHead.next;

    }
````



**思路2-递归**

如果只有一个结点，或者没有结点，则递归终止，无法交换

其它情况：交换后第一个结点变为第二个，第二个变成了head

**代码-2**

````java
public class SoExchangeTwoLinkNode12 {
    //非递归解
    //递归
    public ListNode swapPairs(ListNode head){
        if(head == null || head.next ==null){ // 如果链表为空，或者只有一个结点，那么递归终止
            return head;
        }
        /*否则交换两个结点，交换结束后，第一个结点变为第二个，第二个变为第一个*/
        ListNode newHead = head.next;
        head.next = swapPairs(newHead.next);
        newHead.next = head;
        return  newHead;

    }
}
````



## 字符串

### 求最长无重复字串的长度

题目描述

```` md
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
````

思路

```` java
* 求每个字符开头的最长不重复字串的长度，记录最大值
* 高效的方式是滑动窗口。有两个指针，均不回溯
* 判断当前窗口内有无重复字符，采用 HashSet 作为数据结构
````

````java
class Solution {
    public int lengthOfLongestSubstring(String s){
        int start =0 , end=0, len=0,res=0;
        Set<Character> window = new HashSet<>();
        while(start<s.length()&&end<s.length()){
            if(window.contains(s.charAt(end))){
                window.remove(s.charAt(start));//逐个移动start
                start+=1;
            }else{
                window.add(s.charAt(end));
                len = end-start+1;
                if(len > res) res = len;
                end+=1;
            }
        }
        return res;
    }
}
````

$O(s.length)$

$O(字符集大小)：HashSet 的可能最大值$

### *求最长回文字串（*dp）

题目描述

`````
给你一个字符串 s，找到 s 中最长的回文子串。
示例 1：

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
示例 2：

输入：s = "cbbd"
输出："bb"

`````

**我的解**-思路及注意事项

- 可以对全部回文串分成两类：一类字符个数有奇数个，对称轴是某个元素；一类字符个数偶数个，对称轴是两元素之间
- 遍历一遍字符串，求以每个元素为“中心”（该元素是对称轴，或者对称轴在其后面）时两种情况的最长字串，记录最大值
- 遍历结束，得到答案

复杂度

- 时间：理论上是$O(n) - O(n^2)$，可以做优化 
- 空间：$O(1)$
- ![image-20210511152436565](mdPics/image-20210511152436565.png)

代码

````java
class Solution {
    public String longestPalindrome(String s) {
        String ans = "";
        int len=0,j=0;
        
        for(int i=0; i<s.length();i++){
            len=0;
            j=0;
            //以s.charAt(i)为对称轴
            while(i-j>=0 && i+j<s.length() &&s.charAt(i-j)==s.charAt(i+j) ){
                    len = 2*j+1;
                    if(len>ans.length()){
                        ans = s.substring(i-j,i+j+1);
                    }
                    j = j+1;
            }
            //对称轴在s.charAt(i)后面
            len=0;
            j=1;
            while(i-j+1>=0&&i-j+1<=i && i+j<s.length()&&s.charAt(i-j+1)==s.charAt(i+j)){
                len = 2*j;
                if(len>ans.length()){
                        ans = s.substring(i-j+1,i+j+1);
                    }
                j = j+1;
            }
        }
       
    return ans;
    }
}
````

**动态规划解法**

- 动态规划思路：利用动态规划的思想，每一个回文串都是由更短的回文串组成的。（原问题可以通过一步操作，变成规模更小的子问题来解决）。
- 符号和数学定义：
  - s[i,j] 表示s的一个字串，从i开始，j结束
  - $P(i,j)表示s[i,j]是否是回文串，P(i,j)={true,false)$
- 转移方程：$P(i,j)=P(i+1,j-1)^(S_i == S_j)$
- 边界条件：$P(i,i)=true ; P(i,i+1)=(S_i == S_{i+1})$
- 注意：动态规划本质是查表法，程序执行过程不断填表，既从短串到长串的过程；

````java

public class SoHuiWengCuan {
        public String longestPalindrome(String s) {
            int strlen = s.length();
            if (strlen < 2) {
                return s;
            }

            int maxLen = 1;
            int begin = 0;
            // dp[i][j] 表示 s[i..j] 是否是回文串
            boolean[][] dp = new boolean[strlen][strlen];
            // 初始化：所有长度为 1 的子串都是回文串
            for (int i = 0; i < strlen; i++) {
                dp[i][i] = true;
            }

            char[] charArray = s.toCharArray();
            // 递推开始
            // 先枚举子串长度
            for (int subL = 2; subL <= strlen; subL++) {
                // 枚举左边界，左边界的上限设置可以宽松一些
                for (int i = 0; i < strlen; i++) {
                    // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                    int j = subL + i - 1;
                    // 如果右边界越界，就可以退出当前循环
                    if (j >= strlen) {
                        break;
                    }

                    if (charArray[i] != charArray[j]) {
                        dp[i][j] = false;
                    } else {
                         // 相等的情况下
                   		 // 边界情况：“考虑头尾去掉以后(2个字符)”没有字符剩余，或者剩下一个字符的时候，肯定是回文串
                         //{空，一个字符}的情况
                        if (j - i < 3) { 
                            dp[i][j] = true;
                        } else {
                            dp[i][j] = dp[i + 1][j - 1];
                        }
                    }

                    // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                    if (dp[i][j] && j - i + 1 > maxLen) {
                        maxLen = j - i + 1;
                        begin = i;
                    }
                }
            }
            return s.substring(begin, begin + maxLen);
        }
}
````

复杂度

- 时间复杂度：$O(n^2)$;动态规划状态总数$O(n^2)$ , 求解每一个状态%$O(1)$时间

- 空间复杂度：$O(n^2)$

  

**中心扩展算法**

$public int expandAroundCenter(String s, int left, int right)$ 这个函数设计不错，统一了两种情况

`````java
class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) {
            return "";
        }
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            int len1 = expandAroundCenter(s, i, i);
            int len2 = expandAroundCenter(s, i, i + 1);
            int len = Math.max(len1, len2);
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }

    public int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            --left;
            ++right;
        }
        return right - left - 1;
    }
}

`````

### 字符串Z形转换（*巧妙解）

题目描述：
将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：

P   A   H   N
A P L S I I G
Y   I   R
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。

请你实现这个将字符串进行指定行数变换的函数：

解一

````java
package Hot100.Medium;

public class SoZString03 {

    public String convert(String s, int numRows) {
        if(numRows == 1) return s;
        //由s，numRows 确定需要开辟的数组空间
        int p =  (int)Math.ceil((double)s.length()/(double)(2*numRows-2));//输入 numRows =2 ，p=0；肯定是不行的；数组列维度>=1;
        //照成这个的原因：s.length()/(2*numRows-2)的结果已经是0，0再向上取整还是0；ceil的输入需要是double类型
        char [][] arr = new char[numRows][numRows*p];

        int count=0;
        int i=0;
        int j=0;
        while(count < s.length()){
            //垂直方向填充
            while(i<numRows && count < s.length()){
                arr[i][j] = s.charAt(count);
                count++;
                i++;
            }
            i = i-2;
            j = j+1;

            //斜右上方向填充
            while(i>=0 && j<numRows*p && count < s.length()){
                arr[i][j] = s.charAt(count);
                count++;
                i--;
                j++;
            }
            i = i+2;
            j = j-1;
        }

        StringBuilder sb = new StringBuilder();
        for(int r = 0;r<numRows;r++){
            for(int c=0;c<numRows*p;c++){
                if(arr[r][c]!='\u0000') sb.append(arr[r][c]);
            }
        }
        return sb.toString();

    }

}

````

解二：

````java
public class STDSoZString03 {

    public String convert(String s, int numRows) {

        if (numRows == 1) return s;

        List<StringBuilder> rows = new ArrayList<>();
        for (int i = 0; i < Math.min(numRows, s.length()); i++)
            rows.add(new StringBuilder());

        int curRow = 0;
        boolean goingDown = false;

        for (char c : s.toCharArray()) {
            rows.get(curRow).append(c);
            if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;
            curRow += goingDown ? 1 : -1;
        }

        StringBuilder ret = new StringBuilder();
        for (StringBuilder row : rows) ret.append(row);
        return ret.toString();
    }

}
````

小结：注意使用ceil时，先对入参转double 

### *字符串转数字(aiot)

**题目描述**

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 myAtoi(string s) 的算法如下：

读入字符串并丢弃无用的前导空格
检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。
返回整数作为最终结果。
注意：

本题中的空白字符只包括空格字符 ' ' 。
除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符



**最佳思路解**

确定有限状态机（deterministic finite automaton, DFA）。

<img src="mdPics/image-20210523115731430.png" alt="image-20210523115731430" style="zoom:67%;" />

````java
class Solution {
    public int myAtoi(String str) {
        Automaton automaton = new Automaton();
        int length = str.length();
        for (int i = 0; i < length; ++i) {
            automaton.get(str.charAt(i));
        }
        return (int) (automaton.sign * automaton.ans);
    }
}

class Automaton {
    public int sign = 1;
    public long ans = 0;
    private String state = "start";
    private Map<String, String[]> table = new HashMap<String, String[]>() {{
        put("start", new String[]{"start", "signed", "in_number", "end"});
        put("signed", new String[]{"end", "end", "in_number", "end"});
        put("in_number", new String[]{"end", "end", "in_number", "end"});
        put("end", new String[]{"end", "end", "end", "end"});
    }};

    public void get(char c) {
        state = table.get(state)[get_col(c)];
        if ("in_number".equals(state)) {
            ans = ans * 10 + c - '0';
            ans = sign == 1 ? Math.min(ans, (long) Integer.MAX_VALUE) : Math.min(ans, -(long) Integer.MIN_VALUE);
        } else if ("signed".equals(state)) {
            sign = c == '+' ? 1 : -1;
        }
    }

    private int get_col(char c) {
        if (c == ' ') {
            return 0;
        }
        if (c == '+' || c == '-') {
            return 1;
        }
        if (Character.isDigit(c)) {
            return 2;
        }
        return 3;
    }
}

````





**我的思路**

1-截去开头的空格

2-读取第一个非空字符。如果是“+”"-"号则记录符号

3-读取下一个字符。如果不是数字返回0.如果是数字，记录位置，连续读取至非数字字符，记录位置，返回数字结果。



**坑点**

- $Objects.equals（）$
- 字符串转数字范围
- $parseLong() 和valueOf()$的区别。最大区别是返回值



**我的代码**

```` java
package Hot100.Medium;

import java.util.Objects;

public class SoAoitFunction04 {
    public int myAtoi(String s) {


        if(Objects.equals("",s)) return 0;

        int strLen = s.length();
        int p=0,start=0,end=0;
        char currChar = s.charAt(0);
        boolean sign = true; //默认值是 true , 不存在时默认为+

        while(Objects.equals(currChar,' ')){
            p++;
            if(p>strLen-1) return 0;
            currChar = s.charAt(p);
        }

//符号处理
        if(Objects.equals('+',currChar)){
            sign = true;
            p++;
        }
        if(Objects.equals('-',currChar)){
            sign = false;
            p++;
        }

        if(p>strLen-1) return 0;
        currChar = s.charAt(p);

//处理 '0' 的情况
        while(Objects.equals('0',currChar)){
            p++;
            if(p>strLen-1) return 0;
            currChar = s.charAt(p);
        }

        if(currChar < '1' || currChar > '9'){
            return 0;
        }

        start = p;
        end = p+1; //[,)
        while(currChar >= '0' && currChar <= '9'){ //排除开头是0的情况，后面需要包括0
            p++;
            if(p>strLen-1) break;
            currChar = s.charAt(p);
        }
        end = p;

        String resStr = s.substring(start,end);
        if(resStr.length()>10){ //肯定超出表示整型表示范围内,提前处理；且避免Long.parseLong(resStr)出现错误(比如上百个字符长度数字)
            return sign == true ? Integer.MAX_VALUE : Integer.MIN_VALUE;
        }

        long ansL = Long.parseLong(resStr);
        if(sign == true && ansL > Integer.MAX_VALUE){
            return Integer.MAX_VALUE;
        }else if(sign == false && (-1)*ansL < Integer.MIN_VALUE){
            return Integer.MIN_VALUE;

        }
        int ans = (int)ansL;
        return sign == true ? ans : (-1)*ans;

    }
}

````



### [ 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

**题目描述**


给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

**示例:**

```
输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```

**说明：**

- 所有输入均为小写字母。
- 不考虑答案输出的顺序。

通过次数206,834

提交次数312

**思路**

- 我的思路：自定义一个是否符合"字母异位字符"的比较函数
  - 先比较长度
  - 用HahsMap存, KEY表示字符，Values 表示这个KEY出现的次数
  - O(n^2), O(n)
- 题解思路
  - 一、计数方法，统计一个字符串中字符的出现次数，用“字符+次数” 作为HashMap的键
  - 复杂度分析![image-20210714114830289](mdPics/image-20210714114830289.png)
  - ![image-20210714115430703](mdPics/image-20210714115430703.png)
  - 二、排序方法：对字符排序后，符合“字母异位词分组”的字符串，一定是相同的，可以作为HashMap的Key
    - ![image-20210714115348086](mdPics/image-20210714115348086.png)

### [ 简化路径](https://leetcode-cn.com/problems/simplify-path/)

**题目**

- 给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。

  在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。

  请注意，返回的 规范路径 必须遵循下述格式：

  始终以斜杠 '/' 开头。
  两个目录名之间必须只有一个斜杠 '/' 。
  最后一个目录名（如果存在）不能 以 '/' 结尾。
  此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。
  返回简化后得到的 规范路径 。


**思路**

- ![image-20210726111608699](mdPics/image-20210726111608699.png)

**代码**

- ````java
  class Solution {
      public String simplifyPath(String path) {
          Deque<String> pathQue = new LinkedList<>();
          String[] pathArr = path.split("/");
  
  
          for (String e : pathArr) {
              if (e.equals("") || e.equals(".")) continue;
              else if (e.equals("..")) {
                  if (!pathQue.isEmpty()) {
                      pathQue.pollLast();
                  }
              } else pathQue.offer(e);
          }
  
          return "/" + String.join("/", pathQue);
      }
  }
  ````

  



## 递归

### 爬楼梯

题目描述：假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。



方法1：普通递归，速度慢

`````java
class Solution {
    public int climbStairs(int n) {
       int sum = climb(n);
        return sum;
    }
    public int climb(int step){
        if(step == 2) return 2;
        if(step == 1) return 1;
        return (climb(step-1)+climb(step-2));
    }
}
`````

方法2：带路径保存的递归

速度的提升在于： 避免了重复子问题的求解

````java
class Solution {
    public int climbStairs(int n) {
       int [] ans = new int[n+1]; 
    
       int sum = climb(n,ans);
       return sum;
    }
    public int climb(int step,int[] ans){
        if(ans[step]!=0) return ans[step];

        if(step == 2) return 2;
        if(step == 1) return 1;
        ans[step]=climb(step-1,ans)+climb(step-2,ans);

        return ans[step];
    }
}
````

方法3：循环-自底向上求解

````java
class Solution {
    public int climbStairs(int n) {
       int [] ans = new int[n+1]; 
       
       for(int i=1; i<=n;i++ ){
           if(i ==1 ) ans[i] =1;
           if(i ==2 ) ans[i] =2;
           if(ans[i]==0){
               ans[i] = ans[i-1]+ans[i-2];
           } 
       }
       return ans[n];   
    }
}
````



## 回溯法

### 生成括号

**题目描述**

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

示例 1：

输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
示例 2：

输入：n = 1
输出：["()"]


提示：

1 <= n <= 8

**思路一：**

```
/*回溯法
* 递归过程中的截止条件
* 左括号数量还小于n，可以添加左括号
* 右括号数量小于左括号，可以添加右括号
* 利用这两性质，判定-截止；与回溯-搜索所有可能的解
* 复习：想想，什么是回溯？从某个状态出发，往下一个状态时，有多种可能，在递归构造状态树的过程中，一次枚举所有状态，每次假设一种状态之后，需要回溯，再前进到另一种状态
* */
```

**代码**

````java
public class SoGeneParenthesis10 {
    public List<String> SoGenerateParenthesis(int n){
        List<String> ansList = new ArrayList<>();
        backTrackGen(n,new StringBuilder(),0,0,ansList);
        return ansList;

    }
    private void backTrackGen(int max,StringBuilder strBuilder,int leftPa , int rightPa , List<String> ansList){
        if( leftPa==max && rightPa ==max ){
            ansList.add(strBuilder.toString());
        }
        if(leftPa<max){
            strBuilder.append("(");
            backTrackGen(max,strBuilder,leftPa+1,rightPa,ansList);
            strBuilder.deleteCharAt (strBuilder.length()-1);
        }
        if(rightPa<leftPa){
            strBuilder.append(")");
            backTrackGen(max,strBuilder,leftPa,rightPa+1,ansList);
            strBuilder.deleteCharAt(strBuilder.length()-1);
        }
    }
}
````

**时间复杂度**

我们的复杂度分析依赖于理解 generateParenthesis(n) 中有多少个元素。这个分析超出了本文的范畴，但事实证明这是第 n 个卡特兰数 $$\dfrac{1}{n+1}\dbinom{2n}{n}( n2n	 )$$，这是由 $$\dfrac{4^n}{n\sqrt{n}}$$渐进界定的

- 时间复杂度：$$O( \dfrac{4^n}{\sqrt{n}})$$ ，在回溯过程中，每个答案需要 O(n) 的时间复制到答案数组中。

- 空间复杂度：O(n)，除了答案数组之外，我们所需要的空间取决于递归栈的深度，每一层递归函数需要 O(1)的空间，最多递归 2n层，因此空间复杂度为 O(n)



**思路二，动态规划法**

- 具备最优子结构 (a)b :任何一个括号序列都一定是由 `(` 开头，并且第一个 `(` 一定有一个唯一与之对应的 `)`。这样一来，每一个括号序列可以用 `(a)b` 来表示。(a)b 这个形式中，假设有n个括号，拿掉（），就得到剩下的n-1个括号序列 ab, 这就将原问题装换为子问题

- 用dp[i]表示 n=i 时个括号序列有效组合，那么递推公式就是$dp[i] = "("+dp[m]+")"+dp[k]$

  - $dp[m]就是最优子结构中a部分表示的有效括号序列，dp[k]就是最优子结构中b部分表示的有效括号序列$

- 所有可能解的情况可由枚举 m 和 k 的所有值得到

  - m 和 k具有关系 ： $m+k = i-1$

- 边界条件 dp[0]=""

- 动态规划代码一，自底向上版本

- ````java
  /*
  数据结构：ArrayList<String>[] dp;
      dp[i] 表示 i 个括号的所有可能解
      dp[i] = dp[m]+dp[k]
      m+k=i-1
      构造解："("+dp[m]+")"+dp[k]; 具体构造时，又需要2个for循环
  */
  
  public List<String> SoGenerateParenthesisDp(int n) {
          List<String>[] dp = new ArrayList[n + 1];
          //动态规划表的边界
          List<String> dp0 = new ArrayList<>();
          dp0.add("");
          dp[0] = dp0;
          //开始填表，同时也是求解过程
          for (int i = 1; i <= n; i++) {
              List<String> cur = new ArrayList<>();
              for (int m = 0; m <= i - 1; m++) {
                  int k = i - 1 - m;
                  List<String> dpm = dp[m];
                  List<String> dpk = dp[k];
                  //构造 i 个括号组合的解。也即使动态规划方程（动态规划思想），原问题的解可由最优子问题来求得
  
                  for (String str1 : dpm) {
                      for (String str2 : dpk) {
                          cur.add("(" + str1 + ")" + str2);
                      }
                  }
              }
              dp[i] = cur;
          }
          return dp[n];
      }
  }
  ````

  

- 动态规划代码二，递归版本

- ````java
  public List<String> DpRecur(int n) {
          if (n == 0) {
              List<String> dp0 = new ArrayList<>();
              dp0.add("");
              return dp0;
          }
          List<String> dpn = new ArrayList<>();
          for (int m = 0; m < n; m++) { //求解所有解
              int k = n - m - 1;
              List<String> dpm = DpRecur(m);
              List<String> dpk = DpRecur(k);
              //构造解并添加
              for (String str1 : dpm) {
                  for (String str2 : dpk) {
                      dpn.add("(" + str1 + ")" + str2);
                  }
              }
          }
          return dpn;
      }
  ````

- 



## 深度优先搜索

### 电话号码字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![image-20210529105657686](mdPics/image-20210529105657686.png) 	

示例 

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]

输入：digits = ""
输出：[]

输入：digits = "2"
输出：["a","b","c"]
```

**参考代码**

````java
class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> combinations = new ArrayList<String>();
        if (digits.length() == 0) {
            return combinations;
        }
        Map<Character, String> phoneMap = new HashMap<Character, String>() {{
            put('2', "abc");
            put('3', "def");
            put('4', "ghi");
            put('5', "jkl");
            put('6', "mno");
            put('7', "pqrs");
            put('8', "tuv");
            put('9', "wxyz");
        }};
        backtrack(combinations, phoneMap, digits, 0, new StringBuffer());
        return combinations;
    }

    public void backtrack(List<String> combinations, Map<Character, String> phoneMap, String digits, int index, StringBuffer combination) {
        if (index == digits.length()) {
            combinations.add(combination.toString());
        } else {
            char digit = digits.charAt(index);
            String letters = phoneMap.get(digit);
            int lettersCount = letters.length();
            for (int i = 0; i < lettersCount; i++) {
                combination.append(letters.charAt(i));
                backtrack(combinations, phoneMap, digits, index + 1, combination);
                combination.deleteCharAt(index);
            }
        }
    }
}
````



**我的题解**

````java
//对比参考代码，可以改进的点
//用 Map<Character, String> phoneMap = new HashMap<Character, String>() {{...不是更香吗？初始化更简单put('2', "abc");...
//既然已经使用了Map数据结构，就不用再搞个 List<List<Character>> selectButton = new ArrayList<>(); 存储了

public List<String> letterCombinations(String digits) {
        if(Objects.equals(digits,"")){
            List<String> ans = new ArrayList<>();
            return ans;
        }

        Map<Character,List<Character>> table = new HashMap(8);

        List<Character> num2 = new ArrayList<>();
        num2.add('a');
        num2.add('b');
        num2.add('c');
        table.put('2',num2);

        List<Character> num3 = new ArrayList<>();
        num3.add('d');
        num3.add('e');
        num3.add('f');
        table.put('3',num3);

        List<Character> num4 = new ArrayList<>();
        num4.add('g');
        num4.add('h');
        num4.add('i');
        table.put('4',num4);

        List<Character> num5 = new ArrayList<>();
        num5.add('j');
        num5.add('k');
        num5.add('l');
        table.put('5',num5);

        List<Character> num6 = new ArrayList<>();
        num6.add('m');
        num6.add('n');
        num6.add('o');
        table.put('6',num6);

        List<Character> num7 = new ArrayList<>();
        num7.add('p');
        num7.add('q');
        num7.add('r');
        num7.add('s');
        table.put('7',num7);

        List<Character> num8 = new ArrayList<>();
        num8.add('t');
        num8.add('u');
        num8.add('v');
        table.put('8',num8);

        List<Character> num9 = new ArrayList<>();
        num9.add('w');
        num9.add('x');
        num9.add('y');
        num9.add('z');
        table.put('9',num9);

        //获取每次按键选择的字符列表
        List<List<Character>> selectButton = new ArrayList<>();
        for(int i=0;i<digits.length();i++){
            char c = digits.charAt(i);
            List<Character> temp = table.get(c);
            selectButton.add(temp);
        }

        //输出组合数;遍历每个元素一次，在这个过程保留所有组合的结果
        //递归，深度优先遍历
        /*List<String> ans = new ArrayList<>();
        StringBuilder strBuilder = new StringBuilder();
        for (List<Character> e:selectButton) {
            selectButton.add(e
            for(Character c : e){

            }
        }*/
        int deep = selectButton.size();
        List<String> ans = new ArrayList<>();
        StringBuilder strBd = new StringBuilder();
        getAns(selectButton,0,deep-1,strBd,ans);
        return ans;

    }
    private void getAns(List<List<Character>> selectButton,int step,int deep,StringBuilder strBd,List<String> ans){
        if(step>deep){
            ans.add(strBd.toString());

            return;
        }
        List<Character> thisL = new ArrayList<>();
        thisL = selectButton.get(step);

        for (Character c: thisL
             ) {
            strBd.append(c);
            getAns(selectButton,step+1,deep,strBd,ans);
            strBd.deleteCharAt(step);//回溯
        }

    }
````

### 生成所有组合解

**题目描述**

- 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

  candidates 中的数字可以无限制重复被选取。

  **说明：**

  - 所有数字（包括 `target`）都是正整数。
  - 解集不能包含重复的组合。 

  **示例 1：**

  ```
  输入：candidates = [2,3,6,7], target = 7,
  所求解集为：
  [
    [7],
    [2,2,3]
  ]
  ```

  **示例 2：**

  ```
  输入：candidates = [2,3,5], target = 8,
  所求解集为：
  [
    [2,2,2,2],
    [2,3,3],
    [3,5]
  ]
  ```

**思路**

- 基于DNF搜索全部解，记录符合的解。可以剪枝加快速度

- 此题关键：

  ```
  当一个数，用candidate[dix]表示，可以被选择的时候：有两种选择：
  选 和 不选；注意由于每个数可以选无限制次，所以选择了加入时，“dix” 不增加
  ```

**代码**

- ```java
  package Hot100.Medium;
  
  import Hot100.Easy.ListNode;
  
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.List;
  
  public class SoCombinedNumofTarget16 {
      public List<List<Integer>> combinationSum(int[] candidates, int target){
              //  对candidate 做升序，方便回溯和截枝
          Arrays.sort(candidates);
          System.out.println(Arrays.toString(candidates));
          List<List<Integer>> ans = new ArrayList<>();
          List<Integer> combine = new ArrayList<>();
          soSearch(0, candidates,ans,combine,target);
          return  ans;
  
      }
      private void soSearch(int dix,int[]candidate , List<List<Integer>> ans, List<Integer>combine, int target){
  
          if(target == 0){
              ans.add(new ArrayList<Integer>(combine) );
              return;
          }
          if(dix >= candidate.length || candidate[dix] > target ){
              return ;
          }
          if(candidate[dix] <= target){
             //有两种选择，选择 和 不选择；注意由于每个数可以选无限制次，所以选择了的，dix 不增加
              // 选择candidate[dix]
              combine.add(candidate[dix]);
              soSearch(dix,candidate,ans,combine,target-candidate[dix]);
  
  
              //不选择
             // boolean f = combine.remove(Object(candidate[dix])); //先回溯
              combine.remove(new Integer(candidate[dix]));
              /*本意是传入删除元素并删除，但remove方法删除元素需要是Object类型；恰巧是int[]数组，传入int 元素变成了调用删除指定index
              位置处的元素， candidate[1]=3, 编译器理解成删除 List中Index=3的元素，所以报ArrayList 越界错误
              另外一个知识点： List 删除某一个元素后，index 会自动重排
              */
                soSearch(dix+1,candidate,ans,combine,target);
  
          }
  
  
      }
  }
  ```

**补充**

-  ArrayList<>

  - remove方法有两个形式

    ```
    E remove(int index)
    boolean remove(Object x)    
    ```

    如果List中的元素是int 型，e.g.使用 remove(3) 并不表示删除元素3而是删除Index=3的元素，想删除元素3得用 remove(new Integer(3))

  - ans.add(new ArrayList<Integer>(combine) ); 如果只是 ans.add(combine ), 只是添加了一个combine的引用变量；
  
  

### 生成全部排列

**题目描述**

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

 

示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

**代码**

```java
package Hot100.Medium;

import java.util.ArrayList;
import java.util.List;

public class soFullPermutation17 {
    public List<List<Integer>> permute(int[] nums){
       List<List<Integer>> ans = new ArrayList<>();
       List<Integer> oneRes = new ArrayList<>();
       int[] vs = new int[nums.length];
       for(int i=0;i<vs.length;i++) vs[i]=0;
       dfs(nums,vs, oneRes, ans);
       return ans;

    }
    private void dfs(int[] nums , int[] vs, List<Integer> oneRes ,List<List<Integer>> ans){
        if(oneRes.size() == nums.length){
            ans.add(new ArrayList<Integer>(oneRes));
            return ;
        }
        for(int i =0;i<nums.length;i++){
            if(vs[i] == 0){
                vs[i] = 1;
                oneRes.add(nums[i]);
                dfs(nums,vs,oneRes,ans);
                vs[i]=0;
                oneRes.remove(oneRes.size()-1);
            }
        }
        return ;

    }
}
```



### 生成全部排列(有重复元素) II

**题目描述**

给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

 

示例 1：

输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]

**思路1**

用常规dfs的方式求解，添加进解之前，在判断里面是否有一样的解

缺点太慢了：O(n!(n))

**思路2**

先做排序；

要解决重复问题，我们只要设定一个规则，保证在填第$ \textit{idx}$ 个数的时候**重复数字只会被填入一次即可**

```` java
if (i > 0 && nums[i] == nums[i - 1] && !vis[i - 1]) {    continue; }
````







## 动态规划

### 最大子序列和

题目描述:

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：

输入：nums = [1]
输出：1

1-动态规划解：

用$f(i)$表示 **以num[i]结尾** 的最长序列和

**动态规划方程** $f(i)=max{f(i-1)+nums[i],nums[i]}$

````java
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0, maxAns = nums[0];
        for (int x : nums) {
            pre = Math.max(pre + x, x);
            maxAns = Math.max(maxAns, pre);
        }
        return maxAns;
    }
}

````



2-我的解法 $O(n^2),O(n)$

`````java
class Solution {
    public int maxSubArray(int[] nums) {
        int [] sumArr = new int[nums.length+1];
        sumArr[0] = 0;
        for(int i=1;i<sumArr.length;i++){
            
            sumArr[i] = sumArr[i-1]+nums[i-1];
        }
        int maxSum= Integer.MIN_VALUE;
        for(int i=0;i<sumArr.length;i++){
            for(int j=i+1;j<sumArr.length;j++){
                if(sumArr[j]-sumArr[i] > maxSum) maxSum = sumArr[j] - sumArr[i];
            }
        }
        return maxSum ;

    }
}
`````

3-递归线段树解法，可以求解任意区间，且保存起来。只需要$O(log n)$的时间复杂度可以查询修改



### [不同路径](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

![image-20210722111957467](mdPics/image-20210722111957467.png)

**思路**

- $ans[i][j]=ans[i+1][j]+ans[i][j+1]$
- 子问题，边界条件
- 符号的定义，比如： $ans[i][j] 表示从 Grid[i][j]走到Grid[m-1][n-1]的方法数， 和 表示Grid[i][j]从左上角走到Grid[i][j]的方法数，实现起来就不一样$

**代码**

- `````java
  package Hot100.Medium;
  
  public class So26DiffPath {
  
      private int[][] ans;
      //ans[i][j] 表示从 Grid[i][j] 走到 Grid[m-1][n-1] 的路径数；（只能往下或者往右走）
      //边界条件ans[m-1][*] = 1 Grid[*][n-1] = 1
      //填表
  
  
      public int uniquePaths(int m, int n) {
          ans = new int[m][n];
          for (int i = 0; i < m; i++) ans[i][n - 1] = 1;
          for (int j = 0; j < n; j++) ans[m - 1][j] = 1;
  
          //递归动态规划解法
          // return dps(0, 0);
  
          //循环动态规划
          for(int i = m-2;i>=0;i--){
              for(int j = n-2 ; j>=0 ; j--){
                  ans[i][j] = ans[i+1][j]+ans[i][j+1];
              }
          }
          return ans[0][0];
  
      }
  /*
  
      int dps(int x, int y) {
          if (ans[x][y] != 0) return ans[x][y];
  
          ans[x][y] = dps(x + 1, y) + dps(x, y + 1);
          return ans[x][y];
      }
  */
  
  
  }
  
  `````

- ![image-20210722112349439](mdPics/image-20210722112349439.png)

- $O(mn),O(mn)$

- **最快的是组数数学方法** $O(m),O（1）$



### 不同路径II

**题目描述**

网格中有数量不定的障碍物

**思路1**

- 依旧是dps填表

- 注意边界条件

  <img src="mdPics/image-20210724120029022.png" alt="image-20210724120029022" style="zoom:50%;" />

  

  

- 状态转移方程也做相应调整

**代码**

````java
public int uniquePathsWithObstacles(int[][] obstacleGrid){
        if(obstacleGrid==null||obstacleGrid.length==0) return 0;

        int xBoundary = obstacleGrid.length;
        int yBoundary = obstacleGrid[0].length;
        int [][] dpsGrid = new int[xBoundary][yBoundary];
        //dpsGrid[i][j] means the num of ways from (i,j) to (xBoundary,yBoundary)

        for(int i = xBoundary-1; i>=0;i--){
           if(obstacleGrid[i][yBoundary-1] == 1) break;
           else dpsGrid[i][yBoundary-1] = 1;
        }

        for(int j = yBoundary-1; j>=0;j--){
            if(obstacleGrid[xBoundary-1][j] == 1) break;
            else dpsGrid[xBoundary-1][j] = 1;
        }

        for(int i = xBoundary-2;i>=0;i--){
            for(int j=yBoundary-2;j>=0;j--){
                if(obstacleGrid[i][j]==1) continue;//障碍物不填,为0
                else{
                    dpsGrid[i][j]= (obstacleGrid[i+1][j]==1 ? 0: dpsGrid[i+1][j]) + (obstacleGrid[i][j+1]==1 ? 0 : dpsGrid[i][j+1]);
                }

            }
        }
        return dpsGrid[0][0];
    }
````

![image-20210724120232600](mdPics/image-20210724120232600.png)

效率

- 时间O(m*n)
- 空间O(m*n)

**思路2-利用滚动数组优化空间复杂度**

- 



## 技巧题

### 寻找数组中只出现一次的数

题目描述：一个数组中 $2m+1$ 个数，m=0，1，2，... ；m个数各出现两次，有一个数只出现1次，求这个数；要求$O(1),O(1)$

**技巧：利用异或计算的性质**

$ a \oplus 0 =a$

$a \oplus a =0$ 

**异或运算有交换律和结合律**



### 多数元素

题目描述：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素

题解算法：

````java
//投票算法
class Solution {
    public int majorityElement(int[] nums) {
        int candidate = nums[0];
        int count=0;
        for(int i=0;i<nums.length;i++){
            if(count == 0){
                candidate =nums[i];
                count++;
            }else{
                if(candidate == nums[i]){
                    count++;
                }else{
                    count--;
                }
            }
        }
        return candidate;

    }
}
//算法正确性证明：https://leetcode-cn.com/problems/majority-element/
//O(1),O(1)
````



### 寻找数组中消失的数

题目描述：给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, n] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

示例:

输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]

分析题目：

有限制条件，数组的元素取值为[1,n]，而数组大小为n ；有些元素出现0，1，2 次（实际上此题可扩展为出现任意次）；注意，如果限制条件是出现 {1，2}次, 则可以用异或性质了.

最简单的，我们可以用一个哈希表来记录范围在[1，n]之间的元素是否出现，需要的哈希表长度是n。 这里我们发现，数组长度也是n，那么最好使用数组来充当哈希表。通过一些方法，在便利的过程中，对出现的元素进行标记。

解题思路一：

假设 **元素是** nums[i] 应该映射到 **下标是** nums[i] -1  的位置上；

标记方法：对遍历过程出现元素，对其映射位置的当前值加上数字n ，说明元素出现过至少一次，加n可以方便还原。 注意 ，这里"**哈希结构**"中的key 是 数组下标

```` java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int n = nums.length;
        int x;//元素应该映射到的哈希表的 key 
        
        for(int i =0 ;i<nums.length;i++){
            x = (nums[i]-1)%n; //x 是数nums[i] 该去的位置，逻辑上这里求余实际是没必要的，但不求余通过不了编译
            nums[x] = nums[x]+n ;//+n 的目的，为了标记该数出现，也方便还原数组
        }

        List<Integer> vanishNum = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            if(nums[i]<=n) vanishNum.add(i+1);
            else nums[i] %= n; //还原nums[]
        }
        return vanishNum;

    }
}
````



解题思路二：

与一 大体一致，只是标记方法不同。

对于key: x = (nums[i]-1)%n 

将$nums[x]* (-1)$ 表示已经出现过

```` java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int n = nums.length;
        int x;//元素应该映射到的哈希表的 key 
        
        for(int i =0 ;i<nums.length;i++){
            x = (Math.abs(nums[i])-1)%n; 
            if(nums[x]>=0)  nums[x] = nums[x]*(-1) ;
           
        }

        List<Integer> vanishNum = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            if(nums[i] >=0 ) vanishNum.add(i+1);
            else nums[i] *= (-1); //还原nums[]
        }
        return vanishNum;

    }
}
````

**总结**

一与二的本质是相同的 , 利用原来数组充当哈希表，只是标记方式的不同



### 最大盛水容量（双指针法)

**题目描述**

给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器。

<img src="mdPics/image-20210522094208437.png" alt="image-20210522094208437" style="zoom: 67%;" />

**思路**

两个指针指示一前一尾。每次往里面移动height较小的那个指针。因为水的容量是由高度较低那个决定的。这样我们就缩小了问题的规模。如果我们移动数字较大的那个指针，那么前者「两个指针指向的数字中较小值」不会增加，后者「指针之间的距离」会减小，那么这个乘积只会减小。因此，我们移动数字较大的那个指针是不合理的。因此，我们移动 数字较小的那个指针



````java
class Solution {
    public int maxArea(int[] height) {
    
        int maxVal = 0;
        for(int j=0;j<height.length-1;j++){
            for(int i=j+1;i<height.length;i++){
            if((i-j)*minNum(height[j],height[i]) > maxVal){
                maxVal = (i-j)*minNum(height[j],height[i]);
            }
        }
        }
        return maxVal;

    }

    public int minNum(int a ,int b){
        return a>=b ? b : a;
    }
}
````



### nextPermutatuion

题目描述：给定一个数组，生成下一个排列；如果数据已经降序，下一个排列是升序（即重新开始）

，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

 示例 1：

输入：nums = [1,2,3]
输出：[1,3,2]
示例 2：

输入：nums = [3,2,1]
输出：[1,2,3]
示例 3：

输入：nums = [1,1,5]
输出：[1,5,1]
示例 4：

输入：nums = [1]
输出：[1]



思路分析：

<img src="mdPics/image-20210609101354354.png" alt="image-20210609101354354" style="zoom:50%;" />

代码

```java
package Hot100.Medium;

/*
 * 1 从后往前寻找第一个非降序的数，记为a[i]；找不到是整个排列降序的情况
 * 2 从后往前寻找第一个比a[i]大的数,记为a[j]
 * 3.交换a[i] 和 a[j]
 * 4.并重排[j,...]之后的元素为升序，由于num[j,...] 这部分元素一定是降序，所以直接用双指针交换实现
 * */
public class SolutionNextPermutation11 {
    public void nextPermutation(int[] nums) {
        int i = nums.length - 1;
        while (i > 0) {
            if (nums[i] <= nums[i - 1]) i--;
            else {
                break;
            }
        }

        if (i == 0) {
            reSort(nums,i,nums.length-1);
        } else { //原排列必定不是降序的
            int j = nums.length - 1;
            i--;
            while (j > 0) {
                if (nums[j] <= nums[i]) j--;
                else break;
            }
            swap(nums,i,j);
            reSort(nums,i+1,nums.length-1);
        }

    }
    private void swap(int nums[],int index_i,int index_j){
        int temp = nums[index_i];
        nums[index_i] = nums[index_j];
        nums[index_j] = temp;
    }
    private void reSort(int[] nums, int start , int end){
        while(end>start){
            swap(nums,start,end);
            start++;
            end--;
        }
    }
}

```

更漂亮的代码

````java

class Solution {
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        if (i >= 0) {
            int j = nums.length - 1;
            while (j >= 0 && nums[i] >= nums[j]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i + 1);
    }

    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    public void reverse(int[] nums, int start) {
        int left = start, right = nums.length - 1;
        while (left < right) {
            swap(nums, left, right);
            left++;
            right--;
        }
    }
}

````

复杂度：

$O(N),O(1)$



![image-20210609100551591](mdPics/image-20210609100551591.png)





### 旋转图像

**题目描述**

**思路及代码**

- 关键：对于矩阵中第i行的第j个元素，在旋转后，它出现在倒数第i列的第j 个位置

- <img src="mdPics/image-20210713100536433.png" alt="image-20210713100536433" style="zoom:50%;" />

- 翻译成代码：matrix_new [col] [n-row-1] = matrix [row] [ col]

- 一：使用辅助数组

- 二：原地旋转<img src="mdPics/image-20210713100853253.png" alt="image-20210713100853253" style="zoom:50%;" />

- **需要枚举多少元素？**

- <img src="mdPics/image-20210713101235927.png" alt="image-20210713101235927" style="zoom: 50%;" />

- ````java
  class Solution {
      public void rotate(int[][] matrix) {
          int n = matrix.length;
          for (int i = 0; i < n / 2; ++i) {
              for (int j = 0; j < (n + 1) / 2; ++j) { // for循环的边界参照 图2 确定
                  int temp = matrix[i][j];
                  matrix[i][j] = matrix[n - j - 1][i];
                  matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                  matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                  matrix[j][n - i - 1] = temp;
              }
          }
      }
  }
  
  
  ````

- 三、用翻转代替旋转![image-20210713101009072](mdPics/image-20210713101009072.png)

- ````java
  class Solution {
      public void rotate(int[][] matrix) {
          int n = matrix.length;
          // 水平翻转
          for (int i = 0; i < n / 2; ++i) {
              for (int j = 0; j < n; ++j) {
                  int temp = matrix[i][j];
                  matrix[i][j] = matrix[n - i - 1][j];
                  matrix[n - i - 1][j] = temp;
              }
          }
          // 主对角线翻转
          for (int i = 0; i < n; ++i) {
              for (int j = 0; j < i; ++j) {
                  int temp = matrix[i][j];
                  matrix[i][j] = matrix[j][i];
                  matrix[j][i] = temp;
              }
          }
      }
  }
  ````

  

### 实现pow(x,n)函数

**题目描述**

实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）

示例 1：

输入：x = 2.00000, n = 10
输出：1024.00000
示例 2：

输入：x = 2.10000, n = 3
输出：9.26100
示例 3：

输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25


提示：

<img src="mdPics/image-20210715092027750.png" alt="image-20210715092027750" style="zoom: 80%;" />

**思路**

- 1 暴力解是超时的
- 2 主要思想的快速幂乘
- 3 幂乘递归 OlogN） O(log N)
- 4 幂乘迭代 OlogN） O(1）

**代码**

- ```java
  package Hot100.Medium;
  
  public class So20PowFunction {
      public double myPow(double x, int n) {
          long N = n;
          //if (N == 0) return 1.0; //其实没必要，可注释
          return N > 0 ? recurMul(x, N) : 1 / recurMul(x, -N);
  
      }
  
      private double recurMul(double x, long n) {
          if(n == 0 ) return 1.0;
          double y = recurMul(x,n/2);
          return n%2==0? y*y : y*y*x;
      }
      /*public double myPow(double x , int n){
          long N = n;
          if(N ==0 ) return 1.0; //其实没必要，可注释
  
          return N>0? quickMul(x,N) : 1/quickMul(x,-N);
  
      }*/
      //快速幂乘迭代方法1
      /*private double quickMul(double x ,int n){
          double x_contributor = x;
          double res=1.0;
          String nBinaryStr = Integer.toBinaryString(n);
  
          for(int i=nBinaryStr.length()-1 ; i>=0 ; i--){
              char makeSense = nBinaryStr.charAt(i);
              if(makeSense == '1'){
                  res = res*x_contributor;
              }
              x_contributor *= x_contributor;
          }
          return res;
      }*/
      //快速幂乘迭代方法2
     /* private double quickMul(double x ,long n){
          double res =1.0;
          double x_contributor = x;
          while(n>0){
              if(n%2 == 1 ){
                  res = res*x_contributor;
              }
              x_contributor *= x_contributor;
              n /= 2;
          }
      return res;
      }*/
  }
  ```



### 顺时针输出数组元素

**题目描述**

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

**思路**

i,j 遍历数组， 用iMin, iMax , jMin , jMax 控制上下界

**代码**

````java
public class So21SpiralOrder {
    public List<Integer> spiralOrder(int[][] matrix){
        if( matrix.length == 0 || Objects.isNull(matrix) ) return null;
        int totalElem = matrix.length * matrix[0].length;
        int iMax = matrix.length;
        int jMax = matrix[0].length;
        int iMin = 0;
        int jMin = 0;
        int i=0,j=0;
        List<Integer> res = new ArrayList<>();

        while(totalElem>0){ //维持 (i , j)
            //从左往右
            while(j<jMax && totalElem>0){
                res.add(matrix[i][j]);
                totalElem--;
                j++;
            }
            j--;//回溯
            iMin++;
            i++;//改变方向
            //从上往下
            while(i<iMax && totalElem>0){
                res.add(matrix[i][j]);
                totalElem--;
                i++;
            }
            i--;//回溯
            jMax--;
            j--;//改变方向
            //从右往左
            while(j>=jMin && totalElem>0){
                res.add(matrix[i][j]);
                totalElem--;
                j--;
            }
            j++;//回溯
            iMax--;
            i--;//改变方向
            //从下往上
            while(i>=iMin && totalElem>0){
                res.add(matrix[i][j]);
                totalElem--;
                i--;
            }
            i++;//回溯
            jMin++;
            j++;//改变方向
        }
    return res;
    }
}
````



````java
//Python 巧妙解不过也得有这种函数，另外复杂度是个问题, 内部如何实现不名
def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        while matrix:
            # 削头（第一层）
            res += matrix.pop(0)
            # 将剩下的逆时针转九十度，等待下次被削
            matrix = list(zip(*matrix))[::-1]
        return res

````



**复杂度**： O(m*n) ，O（1）

<img src="mdPics/image-20210716101147655.png" alt="image-20210716101147655" style="zoom:50%;" />



### [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

**题解的模拟思路可以再看看**

我的解：

<img src="mdPics/image-20210720105048986.png" alt="image-20210720105048986" style="zoom:67%;" />

### [旋转链表](https://leetcode-cn.com/problems/rotate-list/)

**题目描述**：

- 给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。
- ![image-20210721095214571](mdPics/image-20210721095214571.png)

**思路**

- 找到 newHead ，位于位于原链表（listLen - k ）位置处；注意：做 k = k% listLen 处理 
- 从newHead走到尾，从尾部连接到oldHead
- 从 oldHead 走到 newHead 前，将newHead前面结点的next 改为Null
- return newHead

**题解思路**

- 思路及算法

  记给定链表的长度为 nn，注意到当向右移动的次数 k \geq nk≥n 时，我们仅需要向右移动 k \bmod nkmodn 次即可。因为每 nn 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第 (n - 1) - (k \bmod n)(n−1)−(kmodn) 个节点（从 00 开始计数）。

  这样，我们可以先将给定的链表连接成环，然后将指定位置断开。

  具体代码中，我们首先计算出链表的长度 nn，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 (n - 1) - (k \bmod n)(n−1)−(kmodn) 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果

  

**代码**

- ````java
   public ListNode rotateRight(ListNode head, int k){
          if(head == null|| k==0) return head;
          int listLen=0;
          ListNode scan = head;
          while(scan != null){
              listLen++;
              scan = scan.next;
          }
          k = k%listLen;
          if(k==0) return head;
    
          ListNode newHead = head;
          int newHeadLoc = listLen - k;
          for(int i =0;i<newHeadLoc;i++){
              newHead = newHead.next;
          }
          scan = newHead;
          while(scan.next != null){
              scan = scan.next;
          }
          scan.next = head ;
          while(scan.next != newHead){
              scan = scan.next;
          }
          scan.next = null;
          return newHead;
      }
  ````

- ![image-20210721095433133](mdPics/image-20210721095433133.png)

### 矩阵置0

**题目描述**

给定一个 `*m* x *n*` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**

<img src="mdPics/image-20210727133050499.png" alt="image-20210727133050499" style="zoom:67%;" />

**思路**

- 先扫描第一列第一行，用两个变量记录是否有0； 随后，这第一行第一列就可以用来做标记数组，标记该行，该列上是否有0；
- 当然更极致，可以只用一个变量记录第一列是否有0；用（0，0）记录第一行是否有0；这样的话，在将矩阵置0时，从最下面开始（倒序开始）

**代码**

- ````java
  public  void setZeros(int[][] matrix) {
          int m = matrix.length;
          int n = matrix[0].length;
          boolean row = false;
          boolean column = false;
          for (int i = 0; i < m; i++) {
              if (matrix[i][0] == 0) {
                  column = true;
                  break;
              }
          }
          for (int j = 0; j < n; j++) {
              if (matrix[0][j] == 0) {
                  row = true;
                  break;
              }
          }
          for (int i = 0; i < m; i++) {
              for(int j =0;j<n;j++){
                  if(matrix[i][j]==0){
                      matrix[0][j] = 0;
                      matrix[i][0] = 0;
                  }
              }
          }
          for(int i=1;i<m;i++){
              for(int j=1;j<n;j++){
                  if(matrix[0][j]==0 || matrix[i][0] == 0)
                      matrix[i][j]=0;
              }
          }
          if(row == true){
              for (int j = 0; j < n; j++) {
                  matrix[0][j] =0;
              }
  
          }
          if(column == true){
              for (int i = 0; i < m; i++) {
                  matrix[i][0] =0;
              }
  
          }
  
      }
  ````

- 









#  JAVA细节

```` java
  String.charAt(index)//
````



## Object 类 和 Objects 类

- 一个是所有类的父类。一个是工具类，提供$Objects.equals( a ,b) $方法

##  数值范围表示

- ![image-20210523110901759](mdPics/image-20210523110901759.png)
- INT_MAX是2147483647到-2147483648,-(-2147483648)会超出INT_MAX  (: 2021.7.15

## 字符串转数值方法

- 题目需要用到字符串转数值的时候。对整个数字字符串进行parsexxx操作，很可能会发生$**java.lang.NumberFormatException:** $错误。 字符串可以是上百个字符。注意这一点。

## HashMap

````java
List<String> list = map.getOrDefault(key,new ArrayList<String>());
list.add(str);
map.put(key,list);
//知识点1
//map.getOrDefault(key,new ArrayList<String>());方法，如果map中无该键，返回指定默认值
 // key 的映射存在于 HashMap 中
        // Not Found - 如果 HashMap 中没有该 key，则返回默认值
        String value1 = sites.getOrDefault(1, "Not Found");
        System.out.println("Value for key 1:  " + value1);

        // key 的映射不存在于 HashMap 中
        // Not Found - 如果 HashMap 中没有该 key，则返回默认值
        String value2 = sites.getOrDefault(4, "Not Found");
        System.out.println("Value for key 4: " + value2);
		//输出结果：
		Value for key 1:  Google
		Value for key 4: Not Found
            
//知识点2
     map.put(key,list);
	//更新Key对应的value

````

## String 的比较

- 内容的比较一定要用 equals() 方法

- == 是基于内存地址的比较。但是有时候有迷惑性

  - ````java
    String s1 = "abs";
    String s2 = "abs";
    s1 == s2 是true;这是因为java首先会在缓冲区查找是否有"String"这个常量对象，有就直接将其地址赋给s2，没有就创建一个"String"
    String s3 = new String("abs")
    s1 == s3 就是 false 了    
    ````

  - 

